{
  
    
        "post0": {
            "title": "MySQL Data Types",
            "content": "Chapter 11 Data Types . MySQL은 숫자 유형, 날짜 및 시간 유형, 문자열(문자 및 바이트) 유형, 공간 유형 및 JSON 데이터 유형과 같은 여러 범주의 SQL 데이터 유형을 지원합니다. 이 장에서는 각 범주의 유형 속성에 대한 개요 및 자세한 설명과 데이터 유형 저장 요구 사항에 대한 요약을 제공합니다. 초기 개요는 의도적으로 간략합니다. 값을 지정할 수 있는 허용되는 형식과 같은 특정 데이터 유형에 대한 추가 정보는 보다 자세한 설명을 참조하십시오. . 데이터 유형 설명은 다음 규칙을 사용합니다. . 정수 유형의 경우 M은 최대 표시 너비를 나타냅니다. 부동 소수점 및 고정 소수점 유형의 경우 M은 저장할 수 있는 총 자릿수(정밀도)입니다. 문자열 유형의 경우 M은 최대 길이입니다. M의 최대 허용 값은 데이터 유형에 따라 다릅니다. | D는 부동 소수점 및 고정 소수점 유형에 적용되며 소수점 이하 자릿수(스케일)를 나타냅니다. 가능한 최대 값은 30이지만 M-2보다 크지 않아야 합니다. | fsp는 TIME, DATETIME 및 TIMESTAMP 유형에 적용되며 소수 초 정밀도를 나타냅니다. 즉, 초의 소수 부분에 대한 소수점 이하 자릿수입니다. fsp 값이 주어진 경우 0에서 6 사이여야 합니다. 값이 0이면 소수 부분이 없음을 나타냅니다. 생략하면 기본 정밀도는 0입니다. (이전 MySQL 버전과의 호환성을 위해 표준 SQL 기본값인 6과 다릅니다.) | 대괄호([ 및 ])는 유형 정의의 선택적 부분을 나타냅니다. | . 11.1 숫자 데이터 유형 . 11.1.1 숫자 데이터 유형 구문 11.1.2 정수 유형(정확한 값) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT 11.1.3 고정 소수점 유형(정확한 값) - DECIMAL, NUMERIC 11.1.4 부동 소수점 유형(근사값) - FLOAT, DOUBLE 11.1.5 비트 값 유형 - BIT 11.1.6 숫자 유형 속성 11.1.7 범위 초과 및 오버플로 처리 . MySQL은 모든 표준 SQL 숫자 데이터 유형을 지원합니다. 이러한 유형에는 정확한 숫자 데이터 유형(INTEGER, SMALLINT, DECIMAL 및 NUMERIC)과 대략적인 숫자 데이터 유형(FLOAT, REAL 및 DOUBLE PRECISION)이 포함됩니다. 키워드 INT는 INTEGER의 동의어이고 키워드 DEC 및 FIXED는 DECIMAL의 동의어입니다. MySQL은 DOUBLE을 DOUBLE PRECISION(비표준 확장)의 동의어로 취급합니다. MySQL은 또한 REAL_AS_FLOAT SQL 모드가 활성화되지 않는 한 REAL을 DOUBLE PRECISION(비표준 변형)의 동의어로 취급합니다. . BIT 데이터 유형은 비트 값을 저장하며 MyISAM, MEMORY, InnoDB 및 NDB 테이블에 대해 지원됩니다. . MySQL이 표현식 평가 중 열에 대한 범위를 벗어난 값의 할당과 오버플로를 처리하는 방법에 대한 정보는 11.1.7절 “범위를 벗어나고 오버플로 처리”를 참조하십시오. . 숫자 데이터 유형의 저장 요구 사항에 대한 정보는 11.7절 “데이터 유형 저장 요구 사항”에서 참조하십시오. . 숫자 값에 대해 작동하는 함수에 대한 설명은 12.6절 “숫자 함수 및 연산자”를 참조하십시오. 숫자 피연산자에 대한 계산 결과에 사용되는 데이터 유형은 피연산자의 유형과 피연산자에 대해 수행되는 연산에 따라 다릅니다. 자세한 내용은 12.6.1절 “산술 연산자”에서 참조하십시오. . 11.1.1 숫자 데이터 유형 구문 . 정수 데이터 유형의 경우 M은 최대 표시 너비를 나타냅니다. 최대 표시 너비는 255입니다. 표시 너비는 11.1.6절 “숫자 유형 속성”에 설명된 대로 유형이 저장할 수 있는 값의 범위와 관련이 없습니다. . 부동 소수점 및 고정 소수점 데이터 유형의 경우 M은 저장할 수 있는 총 자릿수입니다. . MySQL 8.0.17부터 display width 속성은 정수 데이터 유형에 대해 더 이상 사용되지 않습니다. 향후 MySQL 버전에서는 지원이 제거될 것으로 예상해야 합니다. . 숫자 열에 대해 ZEROFILL을 지정하면 MySQL은 자동으로 해당 열에 UNSIGNED 속성을 추가합니다. . MySQL 8.0.17부터 ZEROFILL 속성은 숫자 데이터 유형에 대해 더 이상 사용되지 않습니다. 향후 MySQL 버전에서는 지원이 제거될 것으로 예상해야 합니다. 이 속성의 효과를 생성하는 대체 수단을 사용하는 것을 고려하십시오. 예를 들어, 응용 프로그램은 LPAD() 함수를 사용하여 원하는 너비까지 숫자를 0으로 채우거나 형식이 지정된 숫자를 CHAR 열에 저장할 수 있습니다. . UNSIGNED 속성을 허용하는 숫자 데이터 유형은 SIGNED도 허용합니다. 그러나 이러한 데이터 유형은 기본적으로 signed 되므로 SIGNED 속성은 영향을 미치지 않습니다. . MySQL 8.0.17부터 UNSIGNED 속성은 FLOAT, DOUBLE 및 DECIMAL 유형의 열(및 모든 동의어)에 대해 더 이상 사용되지 않습니다. 향후 MySQL 버전에서는 지원이 제거될 것으로 예상해야 합니다. 이러한 열 대신에 간단한 CHECK 제약 조건을 사용하는 것이 좋습니다. . SERIAL은 BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE의 별칭입니다. . 정수 열 정의에서 SERIAL DEFAULT VALUE는 NOT NULL AUTO_INCREMENT UNIQUE에 대한 별칭입니다. . BIT[(M)] 비트 값 유형입니다. M은 1에서 64 사이의 값당 비트 수를 나타냅니다. M이 생략된 경우 기본값은 1입니다. | TINYINT[(M)] [UNSIGNED] [ZEROFILL] 매우 작은 정수입니다. 부호 있는 범위는 -128 ~ 127입니다. 부호 없는 범위는 0 ~ 255입니다. | BOOL, BOOLEAN 이러한 유형은 TINYINT(1)의 동의어입니다. 값이 0이면 false로 간주됩니다. 0이 아닌 값은 true로 간주됩니다. . | SMALLINT[(M)] [서명되지 않음] [ZEROFILL] 작은 정수. 부호 있는 범위는 -32768 ~ 32767입니다. 부호 없는 범위는 0 ~ 65535입니다. . | MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL] 중간 크기의 정수입니다. 부호 있는 범위는 -8388608 ~ 8388607입니다. 부호 없는 범위는 0 ~ 16777215입니다. . | INT[(M)] [UNSIGNED] [ZEROFILL] 일반 크기의 정수입니다. 부호 있는 범위는 -2147483648 ~ 2147483647입니다. 부호 없는 범위는 0 ~ 4294967295입니다. . | INTEGER[(M)] [UNSIGNED] [ZEROFILL] 이 유형은 INT의 동의어입니다. . | BIGINT[(M)] [UNSIGNED] [ZEROFILL] 큰 정수입니다. 부호 있는 범위는 -9223372036854775808 ~ 9223372036854775807입니다. 부호 없는 범위는 0 ~ 18446744073709551615입니다. . SERIAL은 BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE의 별칭입니다. . BIGINT 열과 관련하여 알아야 할 몇 가지 사항: . 모든 산술은 부호 있는 BIGINT 또는 DOUBLE 값을 사용하여 수행되므로 비트 함수를 제외하고 9223372036854775807(63비트)보다 큰 부호 없는 큰 정수를 사용해서는 안 됩니다! 그렇게 하면 BIGINT 값을 DOUBLE로 변환할 때 반올림 오류로 인해 결과의 마지막 숫자 중 일부가 틀릴 수 있습니다. . | MySQL은 다음과 같은 경우 BIGINT를 처리할 수 있습니다. 정수를 사용하여 BIGINT 열에 큰 부호 없는 값을 저장할 때. | MIN(col_name) 또는 MAX(col_name)에서 col_name은 BIGINT 열을 나타날 때. | 두 피연산자가 모두 정수인 연산자(+, -, * 등)를 사용할 때. | . | 문자열을 사용하여 저장하여 항상 정확한 정수 값을 BIGINT 열에 저장할 수 있습니다. 이 경우 MySQL은 중간 배정밀도 표현을 포함하지 않는 문자열에서 숫자로의 변환을 수행합니다. | -, + 및 * 연산자는 두 피연산자가 모두 정수 값인 경우 BIGINT 산술을 사용합니다. 즉, 두 개의 큰 정수(또는 정수를 반환하는 함수의 결과)를 곱하면 결과가 9223372036854775807보다 크면 예기치 않은 결과가 발생할 수 있습니다. | . | DECIMAL[(M[,D])] [UNSIGNED] [ZEROFILL] 압축된 “정확한” 고정 소수점 수입니다. M은 총 자릿수(정밀도)이고 D는 소수점 이하 자릿수(스케일)입니다. 소수점과 (음수의 경우) - 기호는 M에서 계산되지 않습니다. D가 0이면 값에는 소수점이나 소수 부분이 없습니다. DECIMAL의 최대 자릿수(M)는 65입니다. 지원되는 최대 소수 자릿수(D)는 30입니다. D를 생략하면 기본값은 0입니다. M을 생략하면 기본값은 10입니다. (DECIMAL 리터럴의 텍스트 길이 제한, 섹션 12.25.3, “표현식 처리” 참조) . UNSIGNED는 지정된 경우 음수 값을 허용하지 않습니다. MySQL 8.0.17부터 UNSIGNED 속성은 DECIMAL 유형의 열(및 모든 동의어)에 대해 더 이상 사용되지 않습니다. 향후 MySQL 버전에서는 지원이 제거될 것으로 예상해야 합니다. 이러한 열 대신에 간단한 CHECK 제약 조건을 사용하는 것이 좋습니다. . DECIMAL 열이 있는 모든 기본 계산(+, -, *, /)은 65자리의 정밀도로 수행됩니다. . | DEC[(M[,D])] [UNSIGNED] [ZEROFILL], NUMERIC[(M[,D])] [UNSIGNED] [ZEROFILL], FIXED[(M[,D])] [UNSIGNED] [ZEROFILL] 이러한 유형은 DECIMAL의 동의어입니다. FIXED 동의어는 다른 데이터베이스 시스템과의 호환성을 위해 사용할 수 있습니다. . | FLOAT[(M,D)] [UNSIGNED] [ZEROFILL] 작은(단정밀도) 부동 소수점 숫자입니다. 허용되는 값은 -3.402823466E+38 ~ -1.175494351E-38, 0 및 1.175494351E-38 ~ 3.402823466E+38입니다. IEEE 표준을 기반으로 하는 이론적인 한계입니다. 실제 범위는 하드웨어 또는 운영 체제에 따라 약간 더 작을 수 있습니다. M은 총 자릿수이고 D는 소수점 이하 자릿수입니다. M과 D가 생략되면 값은 하드웨어에서 허용하는 한계까지 저장됩니다. 단정밀도 부동 소수점 숫자는 소수점 이하 약 7자리까지 정확합니다. FLOAT(M,D)는 비표준 MySQL 확장입니다. MySQL 8.0.17부터 이 구문은 더 이상 사용되지 않으며 향후 MySQL 버전에서는 이 구문에 대한 지원이 제거될 것으로 예상해야 합니다. UNSIGNED는 지정된 경우 음수 값을 허용하지 않습니다. MySQL 8.0.17부터 UNSIGNED 속성은 FLOAT 유형의 열(및 모든 동의어)에 대해 더 이상 사용되지 않으며 향후 MySQL 버전에서 제거될 것으로 예상해야 합니다. 이러한 열 대신에 간단한 CHECK 제약 조건을 사용하는 것이 좋습니다. FLOAT를 사용하면 MySQL의 모든 계산이 배정밀도로 수행되기 때문에 예상치 못한 문제가 발생할 수 있습니다. B.3.4.7절. “일치하는 행이 없는 문제 해결”을 참조하십시오. . | FLOAT(p) [UNSIGNED] [ZEROFILL] 부동 소수점 숫자입니다. p는 비트 단위의 정밀도를 나타내지만 MySQL은 결과 데이터 유형에 대해 FLOAT 또는 DOUBLE을 사용할지 여부를 결정하기 위해서만 이 값을 사용합니다. p가 0에서 24 사이이면 데이터 유형은 M 또는 D 값이 없는 FLOAT가 됩니다. p가 25~53이면 데이터 유형은 M 또는 D 값이 없는 DOUBLE이 됩니다. 결과 열의 범위는 이 섹션의 앞부분에서 설명한 단정밀도 FLOAT 또는 배정밀도 DOUBLE 데이터 유형과 동일합니다. . UNSIGNED는 지정된 경우 음수 값을 허용하지 않습니다. MySQL 8.0.17부터 UNSIGNED 속성은 FLOAT 유형의 열(및 모든 동의어)에 대해 더 이상 사용되지 않으며 향후 MySQL 버전에서 제거될 것으로 예상해야 합니다. 이러한 열 대신에 간단한 CHECK 제약 조건을 사용하는 것이 좋습니다. . FLOAT(p) 구문은 ODBC 호환성을 위해 제공됩니다. . | DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL] 일반 크기(배정밀도) 부동 소수점 숫자입니다. 허용되는 값은 -1.7976931348623157E+308 ~ -2.2250738585072014E-308, 0 및 2.2250738585072014E-308 ~ 1.7976931348입니다. IEEE 표준을 기반으로 하는 이론적인 한계입니다. 실제 범위는 하드웨어 또는 운영 체제에 따라 약간 더 작을 수 있습니다. . M은 총 자릿수이고 D는 소수점 이하 자릿수입니다. M과 D가 생략되면 값은 하드웨어에서 허용하는 한계까지 저장됩니다. 배정밀도 부동 소수점 숫자는 대략 소수점 이하 15자리까지 정확합니다. . DOUBLE(M,D)는 비표준 MySQL 확장입니다. MySQL 8.0.17부터 이 구문은 더 이상 사용되지 않으며 향후 MySQL 버전에서는 이 구문에 대한 지원이 제거될 것으로 예상해야 합니다. . UNSIGNED는 지정된 경우 음수 값을 허용하지 않습니다. MySQL 8.0.17부터 UNSIGNED 속성은 DOUBLE 유형의 열(및 모든 동의어)에 대해 더 이상 사용되지 않으며 향후 MySQL 버전에서 지원이 제거될 것으로 예상해야 합니다. 이러한 열 대신에 간단한 CHECK 제약 조건을 사용하는 것이 좋습니다. . | DOUBLE PRECISION[(M,D)] [UNSIGNED] [ZEROFILL], REAL[(M,D)] [UNSIGNED] [ZEROFILL] 이러한 유형은 DOUBLE의 동의어입니다. 예외: REAL_AS_FLOAT SQL 모드가 활성화된 경우 REAL은 DOUBLE이 아닌 FLOAT의 동의어입니다. | . 11.1.2 정수 유형(정확한 값) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT . MySQL은 SQL 표준 정수 유형 INTEGER(또는 INT) 및 SMALLINT를 지원합니다. 표준의 확장으로 MySQL은 정수 유형 TINYINT, MEDIUMINT 및 BIGINT도 지원합니다. 다음 표는 각 정수 유형에 필요한 저장 공간과 범위를 보여줍니다. . Table 11.1 Required Storage and Range for Integer Types Supported by MySQL . Type Storage (Bytes) Minimum Value Signed Minimum Value Unsigned Maximum Value Signed Maximum Value Unsigned . TINYINT | 1 | -128 | 0 | 127 | 255 | . SMALLINT | 2 | -32768 | 0 | 32767 | 65535 | . MEDIUMINT | 3 | -8388608 | 0 | 8388607 | 16777215 | . INT | 4 | -2147483648 | 0 | 2147483647 | 4294967295 | . BIGINT | 8 | -2^63 | 0 | 2^63-1 | 2^64-1 | . 11.1.3 고정 소수점 유형(정확한 값) - DECIMAL, NUMERIC . DECIMAL 및 NUMERIC 유형은 정확한 숫자 데이터 값을 저장합니다. 이러한 유형은 예를 들어 화폐 데이터와 같이 정확한 정밀도를 유지하는 것이 중요할 때 사용됩니다. MySQL에서 NUMERIC은 DECIMAL로 구현되어 있으므로 DECIMAL에 대한 다음 설명은 NUMERIC에도 동일하게 적용됩니다. . MySQL은 DECIMAL 값을 바이너리 형식으로 저장합니다. 12.25절. “정밀도 연산”을 참조하십시오. . DECIMAL 열 선언에서 정밀도와 스케일은 지정될 수 있으며 일반적으로 지정됩니다. 예를 들어: . salary DECIMAL(5,2) . 이 예에서 5는 정밀도이고 2는 스케일입니다. 정밀도는 값에 대해 저장된 유효 자릿수를 나타내고 스케일은 소수점 다음에 저장할 수 있는 자릿수를 나타냅니다. . 표준 SQL에서는 DECIMAL(5,2)이 5자리와 2자리 소수로 모든 값을 저장할 수 있어야 하므로 급여 열에 저장할 수 있는 값의 범위는 -999.99에서 999.99입니다. . 표준 SQL에서 DECIMAL(M) 구문은 DECIMAL(M,0)과 동일합니다. 유사하게, 구문 DECIMAL은 DECIMAL(M,0)과 동일하며, 여기서 M의 값을 결정하도록 구현이 허용됩니다. MySQL은 DECIMAL 구문의 이러한 변형 형태를 모두 지원합니다. M의 기본값은 10입니다. . 스케일이 0이면 DECIMAL 값에는 소수점이나 소수 부분이 포함되지 않습니다. . DECIMAL의 최대 자릿수는 65이지만 지정된 DECIMAL 열의 실제 범위는 지정된 열의 정밀도 또는 소수 자릿수로 제한될 수 있습니다. 이러한 열에 지정된 스케일에서 허용하는 것보다 더 많은 소수점 이하 자릿수가 있는 값이 지정되면 값이 해당 스케일로 변환됩니다. (정확한 동작은 운영 체제에 따라 다르지만 일반적으로 효과는 허용되는 자릿수로 잘립니다.) . 11.1.4 부동 소수점 유형(근사값) - FLOAT, DOUBLE . FLOAT 및 DOUBLE 유형은 대략적인 숫자 데이터 값을 나타냅니다. MySQL은 단정밀도 값에 4바이트를 사용하고 배정밀도 값에 8바이트를 사용합니다. . FLOAT의 경우, SQL 표준은 괄호 안에 키워드 FLOAT 다음에 오는 비트 단위의 정밀도(지수 범위가 아님)의 선택적 사양을 허용합니다. ; 즉, FLOAT(p)입니다. MySQL은 이 선택적 정밀도 사양도 지원하지만 FLOAT(p)의 정밀도 값은 저장소 크기를 결정하는 데만 사용됩니다. 0에서 23 사이의 정밀도는 4바이트 단정밀도 FLOAT 열을 생성합니다. 24에서 53 사이의 정밀도는 8바이트 배정밀도 DOUBLE 열을 생성합니다. . MySQL은 FLOAT(M,D) 또는 REAL(M,D) 또는 DOUBLE PRECISION(M,D)과 같은 비표준 구문을 허용합니다. 여기서 (M,D)는 총 M자리까지 저장할 수 있으며 그 중 D자리는 소수점 이하일 수 있음을 의미합니다. 예를 들어, FLOAT(7,4)로 정의된 열은 -999.9999로 표시됩니다. MySQL은 값을 저장할 때 반올림을 수행하므로 FLOAT(7,4) 열에 999.00009를 삽입하면 대략적인 결과는 999.0001이 됩니다. . MySQL 8.0.17부터 비표준 FLOAT(M,D) 및 DOUBLE(M,D) 구문은 더 이상 사용되지 않으며 향후 MySQL 버전에서 이에 대한 지원이 제거될 것으로 예상해야 합니다. . 부동 소수점 값은 근사치이며 정확한 값으로 저장되지 않기 때문에 비교 시 부동 소수점 값을 정확한 값으로 처리하려고 하면 문제가 발생할 수 있습니다. 또한 플랫폼 또는 구현 종속성의 영향을 받습니다. 자세한 내용은 B.3.4.8절. “부동 소수점 값 문제”에서 참조하십시오. . 최대 이식성을 위해 대략적인 숫자 데이터 값을 저장해야 하는 코드는 정밀도나 자릿수를 지정하지 않고 FLOAT 또는 DOUBLE PRECISION을 사용해야 합니다. . 11.1.5 비트 값 유형 - BIT . BIT 데이터 유형은 비트 값을 저장하는 데 사용됩니다. BIT(M) 유형은 M비트 값을 저장할 수 있습니다. M의 범위는 1에서 64까지입니다. . 비트 값을 지정하려면 b’value’ 표기법을 사용할 수 있습니다. 값은 0과 1을 사용하여 작성된 이진 값입니다. 예를 들어 b’111’과 b’10000000’은 각각 7과 128을 나타냅니다. 9.1.5절. “비트 값 리터럴”을 참조하십시오. . M 비트보다 작은 BIT(M) 열에 값을 할당하면 값이 왼쪽에 0으로 채워집니다. 예를 들어, BIT(6) 열에 b’101’ 값을 할당하는 것은 사실상 b’000101’을 할당하는 것과 같습니다. . NDB 클러스터. 주어진 NDB 테이블에 사용된 모든 BIT 열의 최대 결합 크기는 4096비트를 초과할 수 없습니다. . 11.1.6 숫자 유형 속성 . MySQL은 유형에 대한 기본 키워드 다음에 오는 괄호 안에 정수 데이터 유형의 표시 너비를 선택적으로 지정하기 위한 확장을 지원합니다. 예를 들어, INT(4)는 표시 너비가 4자리인 INT를 지정합니다. 이 선택적 표시 너비는 공백으로 왼쪽을 채워 열에 지정된 너비보다 작은 너비를 갖는 정수 값을 표시하기 위해 애플리케이션에서 사용할 수 있습니다. (즉, 이 너비는 결과 집합과 함께 반환된 메타데이터에 존재합니다. 사용 여부는 응용 프로그램에 달려 있습니다.) . 표시 너비는 열에 저장할 수 있는 값의 범위를 제한하지 않습니다. 또한 열 표시 너비보다 넓은 값이 올바르게 표시되는 것을 방지하지도 않습니다. 예를 들어, SMALLINT(3)으로 지정된 열의 일반적인 SMALLINT 범위는 -32768 ~ 32767이며 세 자리에서 허용하는 범위를 벗어난 값은 세 자리 이상을 사용하여 전체가 표시됩니다. . 선택적(비표준) ZEROFILL 속성과 함께 사용하면 공백의 기본 패딩이 0으로 바뀝니다. 예를 들어 INT(4) ZEROFILL로 선언된 열의 경우 값 5는 0005로 검색됩니다. . NOTE ZEROFILL 속성은 표현식 또는 UNION 쿼리와 관련된 열에 대해 무시됩니다. ZEROFILL 속성이 있는 정수 열에 표시 너비보다 큰 값을 저장하면 MySQL이 일부 복잡한 조인에 대한 임시 테이블을 생성할 때 문제가 발생할 수 있습니다. 이러한 경우 MySQL은 데이터 값이 열 표시 너비에 맞는다고 가정합니다. . MySQL 8.0.17부터 ZEROFILL 속성은 정수 데이터 유형에 대한 표시 너비 속성과 마찬가지로 숫자 데이터 유형에 대해 더 이상 사용되지 않습니다. 향후 MySQL 버전에서는 ZEROFILL 지원 및 정수 데이터 유형에 대한 표시 너비가 제거될 것으로 예상해야 합니다. 이러한 속성의 효과를 생성하는 대체 수단을 사용하는 것을 고려하십시오. 예를 들어, 응용 프로그램은 LPAD() 함수를 사용하여 원하는 너비까지 숫자를 0으로 채우거나 형식이 지정된 숫자를 CHAR 열에 저장할 수 있습니다. . 모든 정수 유형은 선택적(비표준) UNSIGNED 속성을 가질 수 있습니다. 열에 음수가 아닌 숫자만 허용하거나 열에 더 큰 상위 숫자 범위가 필요한 경우 부호 없는 유형을 사용할 수 있습니다. 예를 들어, INT 열이 UNSIGNED이면 열 범위의 크기는 동일하지만 끝점은 -2147483648 및 2147483647에서 0 및 4294967295로 위로 이동합니다. . 부동 소수점 및 고정 소수점 유형도 UNSIGNED일 수 있습니다. 정수 유형과 마찬가지로 이 속성은 음수 값이 열에 저장되는 것을 방지합니다. 정수 유형과 달리 열 값의 상위 범위는 동일하게 유지됩니다. MySQL 8.0.17부터 UNSIGNED 속성은 FLOAT, DOUBLE 및 DECIMAL(및 모든 동의어) 유형의 열에 대해 더 이상 사용되지 않으며 향후 MySQL 버전에서 지원이 제거될 것으로 예상해야 합니다. 이러한 열 대신에 간단한 CHECK 제약 조건을 사용하는 것이 좋습니다. . 숫자 열에 ZEROFILL을 지정하면 MySQL은 자동으로 UNSIGNED 속성을 추가합니다. . 정수 또는 부동 소수점 데이터 유형은 AUTO_INCREMENT 속성을 가질 수 있습니다. 인덱싱된 AUTO_INCREMENT 열에 NULL 값을 삽입하면 열이 다음 시퀀스 값으로 설정됩니다. 일반적으로 값은 현재 테이블에 있는 열의 가장 큰 값인 값+1입니다. (AUTO_INCREMENT 시퀀스는 1로 시작합니다.) . NO_AUTO_VALUE_ON_ZERO SQL 모드가 활성화되지 않는 한 0을 AUTO_INCREMENT 열에 저장하는 것은 NULL을 저장하는 것과 같은 효과를 가집니다. . AUTO_INCREMENT 값을 생성하기 위해 NULL을 삽입하려면 열이 NOT NULL로 선언되어야 합니다. 열이 NULL로 선언된 경우 NULL을 삽입하면 NULL이 저장됩니다. 다른 값을 AUTO_INCREMENT 열에 삽입하면 해당 열이 해당 값으로 설정되고 시퀀스가 ​​재설정되어 다음 자동 생성 값이 삽입된 값에서 순차적으로 따라옵니다. . AUTO_INCREMENT 열에 대한 음수 값은 지원되지 않습니다. . CHECK 제약 조건은 AUTO_INCREMENT 속성이 있는 열을 참조할 수 없으며 CHECK 제약 조건에서 사용되는 기존 열에 AUTO_INCREMENT 속성을 추가할 수도 없습니다. . MySQL 8.0.17부터 AUTO_INCREMENT 지원은 FLOAT 및 DOUBLE 열에 대해 더 이상 사용되지 않습니다. MySQL의 향후 버전에서 제거될 것으로 예상해야 합니다. 이러한 열에서 AUTO_INCREMENT 속성을 제거하거나 정수 유형으로 변환하는 것을 고려하십시오. . 11.1.7 범위 초과 및 오버플로 처리 . MySQL이 열 데이터 유형의 허용 범위를 벗어난 숫자 열에 값을 저장할 때 결과는 당시에 유효한 SQL 모드에 따라 다릅니다. . 엄격한 SQL 모드가 활성화되면 MySQL은 SQL 표준에 따라 범위를 벗어난 값을 오류와 함께 거부하고 삽입이 실패합니다. | 제한 모드가 활성화되지 않은 경우 MySQL은 값을 열 데이터 유형 범위의 적절한 끝점으로 자르고 대신 결과 값을 저장합니다. 범위를 벗어난 값이 정수 열에 할당되면 MySQL은 열 데이터 유형 범위의 해당 끝점을 나타내는 값을 저장합니다. 부동 소수점 또는 고정 소수점 열에 지정된(또는 기본) 정밀도 및 스케일이 암시하는 범위를 초과하는 값이 할당되면 MySQL은 해당 범위의 해당 끝점을 나타내는 값을 저장합니다. | . 테이블 t1에 다음 정의가 있다고 가정합니다. . CREATE TABLE t1 (i1 TINYINT, i2 TINYINT UNSIGNED); . 엄격한 SQL 모드가 활성화되면 범위 초과 오류가 발생합니다. . mysql&gt; SET sql_mode = &#39;TRADITIONAL&#39;; mysql&gt; INSERT INTO t1 (i1, i2) VALUES(256, 256); ERROR 1264 (22003): Out of range value for column &#39;i1&#39; at row 1 mysql&gt; SELECT * FROM t1; Empty set (0.00 sec) . 엄격한 SQL 모드가 활성화되지 않은 경우 경고와 함께 클리핑이 발생합니다. . mysql&gt; SET sql_mode = &#39;&#39;; mysql&gt; INSERT INTO t1 (i1, i2) VALUES(256, 256); mysql&gt; SHOW WARNINGS; ++++ | Level | Code | Message | ++++ | Warning | 1264 | Out of range value for column &#39;i1&#39; at row 1 | | Warning | 1264 | Out of range value for column &#39;i2&#39; at row 1 | ++++ mysql&gt; SELECT * FROM t1; +++ | i1 | i2 | +++ | 127 | 255 | +++ . 엄격한 SQL 모드가 활성화되지 않은 경우 클리핑으로 인해 발생하는 열 할당 변환은 ALTER TABLE, LOAD DATA, UPDATE 및 다중 행 INSERT 문에 대한 경고로 보고됩니다. 엄격 모드에서는 이러한 명령문이 실패하고 테이블이 트랜잭션 테이블인지 여부 및 기타 요인에 따라 일부 또는 모든 값이 삽입되거나 변경되지 않습니다. 자세한 내용은 5.1.11절. “서버 SQL 모드”에서 참조하십시오. . 숫자 표현식 평가 중 오버플로로 인해 오류가 발생합니다. 예를 들어, 가장 큰 부호 있는 BIGINT 값은 9223372036854775807이므로 다음 표현식은 오류를 생성합니다. . mysql&gt; SELECT 9223372036854775807 + 1; ERROR 1690 (22003): BIGINT value is out of range in &#39;(9223372036854775807 + 1)&#39; . 이 경우 작업이 성공하려면 값을 unsigned로 변환합니다. . mysql&gt; SELECT CAST(9223372036854775807 AS UNSIGNED) + 1; +-+ | CAST(9223372036854775807 AS UNSIGNED) + 1 | +-+ | 9223372036854775808 | +-+ . 오버플로 발생 여부는 피연산자의 범위에 따라 다르므로 DECIMAL 값의 범위가 정수보다 크기 때문에 앞의 표현식을 처리하는 또 다른 방법은 정확한 값 산술을 사용하는 것입니다. . mysql&gt; SELECT 9223372036854775807.0 + 1; ++ | 9223372036854775807.0 + 1 | ++ | 9223372036854775808.0 | ++ . 하나가 UNSIGNED 유형인 정수 값 사이의 빼기는 기본적으로 부호 없는 결과를 생성합니다. 그렇지 않으면 결과가 음수였을 경우 오류가 발생합니다. . mysql&gt; SET sql_mode = &#39;&#39;; Query OK, 0 rows affected (0.00 sec) mysql&gt; SELECT CAST(0 AS UNSIGNED) - 1; ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#39;(cast(0 as unsigned) - 1)&#39; . NO_UNSIGNED_SUBTRACTION SQL 모드가 활성화된 경우 결과는 음수입니다. . mysql&gt; SET sql_mode = &#39;NO_UNSIGNED_SUBTRACTION&#39;; mysql&gt; SELECT CAST(0 AS UNSIGNED) - 1; +-+ | CAST(0 AS UNSIGNED) - 1 | +-+ | -1 | +-+ . 이러한 작업의 결과가 UNSIGNED 정수 열을 업데이트하는 데 사용되는 경우 결과는 열 유형의 최대값으로 잘리거나 NO_UNSIGNED_SUBTRACTION이 활성화된 경우 0으로 잘립니다. 엄격한 SQL 모드가 활성화되면 오류가 발생하고 열이 변경되지 않은 상태로 유지됩니다. . 11.2 날짜 및 시간 데이터 유형 . 11.2.1 Date and Time Data Type Syntax 11.2.2 The DATE, DATETIME, and TIMESTAMP Types 11.2.3 The TIME Type 11.2.4 The YEAR Type 11.2.5 Automatic Initialization and Updating for TIMESTAMP and DATETIME 11.2.6 Fractional Seconds in Time Values 11.2.7 Conversion Between Date and Time Types 11.2.8 2-Digit Years in Dates . 시간 값을 나타내는 날짜 및 시간 데이터 유형은 DATE, TIME, DATETIME, TIMESTAMP 및 YEAR입니다. 각 임시 유형에는 유효한 값 범위와 MySQL이 나타낼 수 없는 유효하지 않은 값을 지정할 때 사용할 수 있는 “0” 값이 있습니다. TIMESTAMP 및 DATETIME 유형에는 11.2.5절. “TIMESTAMP 및 DATETIME에 대한 자동 초기화 및 업데이트”에 설명된 특수한 자동 업데이트 동작이 있습니다. . 임시 데이터 유형의 저장 요구 사항에 대한 정보는 11.7절. “데이터 유형 저장 요구 사항”에서 참조하십시오. . 시간 값에 대해 작동하는 함수에 대한 설명은 12.7절. “날짜 및 시간 함수”를 참조하십시오. . 날짜 및 시간 유형으로 작업할 때 다음과 같은 일반적인 고려 사항을 염두에 두십시오. . MySQL은 표준 출력 형식으로 주어진 날짜 또는 시간 유형에 대한 값을 검색하지만 사용자가 제공하는 입력 값에 대한 다양한 형식을 해석하려고 시도합니다(예: 날짜 또는 날짜에 할당하거나 비교할 값을 지정할 때 시간 유형). 날짜 및 시간 유형에 대해 허용되는 형식에 대한 설명은 9.1.3절. “날짜 및 시간 리터럴”을 참조하십시오. 유효한 값을 제공해야 합니다. 다른 형식의 값을 사용하면 예측할 수 없는 결과가 발생할 수 있습니다. . | MySQL은 여러 형식으로 값을 해석하려고 시도하지만 날짜 부분은 항상 월-일-년 또는 일-월-보다는 년-월-일 순서(예: ‘98-09-04’)로 지정해야 합니다. 다른 곳에서 일반적으로 사용되는 연도 순서(예: ‘09-04-98’, ‘04-09-98’). 다른 순서의 문자열을 년-월-일 순서로 변환하려면 STR_TO_DATE() 함수가 유용할 수 있습니다. . | 2자리 연도 값을 포함하는 날짜는 세기를 알 수 없기 때문에 모호합니다. MySQL은 다음 규칙을 사용하여 2자리 연도 값을 해석합니다. . 70-99 범위의 연도 값은 1970-1999가 됩니다. | 00-69 범위의 연도 값은 2000-2069년이 됩니다. | . | . 11.2.8절. “2자리 연도”도 참조하십시오. . 한 시간 유형에서 다른 시간 유형으로의 값 변환은 11.2.7절. “날짜 및 시간 유형 간 변환”의 규칙에 따라 발생합니다. . | 값이 숫자 컨텍스트에서 사용되는 경우 MySQL은 날짜 또는 시간 값을 숫자로 자동 변환하고 그 반대의 경우도 마찬가지입니다. . | 기본적으로 MySQL은 범위를 벗어나거나 해당 유형에 대해 유효하지 않은 날짜 또는 시간 유형 값을 발견하면 값을 해당 유형의 “0” 값으로 변환합니다. 예외는 범위를 벗어난 TIME 값이 TIME 범위의 적절한 끝점으로 잘리는 것입니다. . | SQL 모드를 적절한 값으로 설정하면 MySQL이 지원하기를 원하는 날짜의 종류를 보다 정확하게 지정할 수 있습니다. (섹션 5.1.11, “서버 SQL 모드”를 참조하십시오.) ALLOW_INVALID_DATES SQL 모드를 활성화하여 MySQL이 ‘2009-11-31’과 같은 특정 날짜를 수락하도록 할 수 있습니다. 이는 향후 처리를 위해 사용자가 지정한(예: 웹 형식) “잘못된” 값을 데이터베이스에 저장하려는 경우에 유용합니다. 이 모드에서 MySQL은 월이 1에서 12 사이의 범위에 있고 일이 1에서 31 사이에 있는지만 확인합니다. . | MySQL에서는 DATE 또는 DATETIME 열에 일 또는 월과 일이 0인 날짜를 저장할 수 있습니다. 이것은 정확한 날짜를 알 수 없는 생년월일을 저장해야 하는 응용 프로그램에 유용합니다. 이 경우 날짜를 ‘2009-00-00’ 또는 ‘2009-01-00’으로 저장하면 됩니다. 그러나 이와 같은 날짜를 사용하면 완전한 날짜가 필요한 DATE_SUB() 또는 DATE_ADD()와 같은 함수에 대해 올바른 결과를 기대해서는 안 됩니다. 날짜에서 0월 또는 일 부분을 허용하지 않으려면 NO_ZERO_IN_DATE 모드를 활성화하십시오. . | MySQL에서는 ‘0000-00-00’의 “0” 값을 “더미 날짜”로 저장할 수 있습니다. 경우에 따라 이것은 NULL 값을 사용하는 것보다 더 편리하고 더 적은 데이터와 인덱스 공간을 사용합니다. ‘0000-00-00’을 허용하지 않으려면 NO_ZERO_DATE 모드를 활성화하십시오. . | 커넥터/ODBC를 통해 사용되는 “0” 날짜 또는 시간 값은 ODBC가 이러한 값을 처리할 수 없기 때문에 자동으로 NULL로 변환됩니다. . | . 다음 표는 각 유형에 대한 “0” 값의 형식을 보여줍니다. “0” 값은 특별하지만 표에 표시된 값을 사용하여 명시적으로 저장하거나 참조할 수 있습니다. 쓰기가 더 쉬운 ‘0’ 또는 0 값을 사용하여 이 작업을 수행할 수도 있습니다. 날짜 부분(DATE, DATETIME 및 TIMESTAMP)을 포함하는 시간 유형의 경우 이러한 값을 사용하면 경고 또는 오류가 발생할 수 있습니다. 정확한 동작은 엄격 및 NO_ZERO_DATE SQL 모드가 활성화된 경우에 따라 다릅니다. 5.1.11절. “서버 SQL 모드”를 참조하십시오. . Data Type “Zero” Value . DATE | ‘0000-00-00’ | . TIME | ‘00:00:00’ | . DATETIME | ‘0000-00-00 00:00:00’ | . TIMESTAMP | ‘0000-00-00 00:00:00’ | . YEAR | 0000 | .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/database/dbms/mysql/datatype/2021/11/01/post007.html",
            "relUrl": "/markdown/database/dbms/mysql/datatype/2021/11/01/post007.html",
            "date": " • Nov 1, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "파이썬 기반의 대규모 알고리즘 트레이딩 시스템 소개",
            "content": "Algorithm Trading System . 알고리즘 트레이딩 = 증권 업무 자동화 시스템 업무 : 증권, 자산운용 혼자서 돈을 버는 기계가 아니다. . 셀 사이드 vs 바이 사이드 . 바이 사이드 : 자산운용. 어떤 증권이 오를 것인가. 이 과정에서 컴퓨터 시스템과 알고리즘을 사용하는 것을 Quant Investment, 즉 퀀트 운용이라고 한다. 퀀트 운용은 알고리즘 트레이딩과 다르다. 퀀트 운용에는 퀀트 펀드, 전략 인덱스, 로보 어드바이저 등이 있다. 퀀트 운용에서는 주문이 나가지 않는다. 거래소랑 네트워크로 연결되어 있지 않다. 반면 알고리즘 트레이딩은 거래소와 연결이 되어 실제 주문을 내고 변경하고 취소하는 주문의 제어가 같이 이루어진다. 퀀트 전략 + 실제 네트워크를 통한 트레이딩이 시스템 트레이딩이다. 근데 시스템 트레이딩은 성격이 바이 사이드에 가깝다. 알고리즘 트레이딩에서 시스템 트레이딩이 차지하는 영역은 작다. 대부분은 대량 최적 집행과 HFT 마켓 메이킹이다. | . 알고리즘 트레이딩 . 대량 최적 집행(Optimal Execution) : 대량 주문을 쪼개서 보내는 것. 대표적인 것이 TWAP(Time Weighted Average Price) | 마켓 메이킹(Market Making) 유동성 공급(LP; Liquidity Providing) | 매수/매도 양방향 지정가 주문 지정가 주문(Limit Order) : FIFO Queue. 줄 서서 사거나 파는 사람들. | 시장가 주문(Market Order) : 큐에서 주문 체결(소모). 줄 서지 않고 바로 사거나 파는 사람들. 가격 필드는 없고 수량 필드만 주어진다. 만약 매수를 한다면 팔겠다는 FIFO Queue에 가서 내가 사고 싶은 수량만큼 사서 받아가는 것. 그럼 거래가 체결되는 것. 큐를 따라서 쭈욱 올라가는 것을 Sweeping이라고 함. 이런 스위핑을 보통 신문에서는 매매 사고라고 한다. | High Frequency Trading. 대부분은 시장가 주문을 한다. 누군가 지정가 주문으로 기다려줘야 한다. 근데 마켓 메이킹은 사겠다는 사람에겐 팔고 팔겠다고 하는 사람에겐 사는 역할을 해서 중간 센터같은 존재다. 다만 살 때는 싸게 사고 팔 때는 비싸게 판다. 사는 가격과 파는 가격의 차이를 스프레드라고 부른다. 수익 = 매수/매도 스프레드 * 거래량 리스크 관리 : 포지션/변동성/추세에 따른 스프레드 조정 | . | . | 일반적인 업무 자동화 시스템과의 차이점 핵심 비즈니스 로직(전략)이 고정되어 있지 않음. 변화하는 시장 상황에 따라 지속적인 업그레이드 필요 | 개별 사용자(트레이더) 별로 비즈니스 로직을 별도 개발 및 적용 | 사용 및 관리가 쉬운 스크립트 구현 선호 | . | 오작동 = 초대형 손실 다양한 테스트 환경 및 시나리오 요구 조건 필요 | . | . | . 알고리즘 트레이딩과 파이썬 . 분석 매매 단일 플랫폼 훌륭한 시장 분석 없이 훌륭한 매매 전략은 생기지 않는다 | 알고리즘 트레이딩의 파워는 자동화/대량처리를 통한 비용절감이다 | 매매에 필요한 파라미터를 수동으로 결정하면 자동화/대량처리 불가능 | 입력 실수로 인한 사고 위험 | . | 알고리즘 트레이딩이 원래의 파워를 발휘하려면 대규모의 실시간 병렬처리 시장분석 | 시장 분석 결과를 사용한 전략 파라미터 자동 결정 및 검증 | 대규모의 트레이딩 업무 및 운용전략 동시수행을 통한 비용 절감 | . | . | 그럼 왜 파이썬? 분석 매매 단일 플랫폼 구현 가능 다양한 분석 라이브러리 연동 | interacitve console 기반의 실시간 시장 분석 가능 | . | 전략(비즈니스 로직) 코드 개발 및 관리 개발 생산성 향상 | 클러스터 상에서 사용자의 비즈니스 로직의 관리/배포 용이 | . | 다양한 컴포넌트 연결 다양한 미들웨어, 데이터베이스 및 라이브러리 연결 용이 | . | . | . Python Technology Stack . 파이썬 시스템 - anaconda | 데이터베이스 - redis-py, pytables, pymongo, log4mongo | 자료 관리 및 분석 - numpy, pandas, statsmodels, ta-lib | 시각화 - matplotlib, seaborn | 실시간 시장분석 - ipython, jupyter | 메시지 미들웨어 - simplejson, ujson, pyzmq | Finite State Machine - fysom | 프로세스 관리 - psutil, apscheduler, fabric, supervisord | 사용자 인터페이스 - tornado, django | 시장 정보 . Tick Data 종목정보, 호가, 체결, 프로그램 매매, 투자자 정보 등 | 거래소로부터 전송되는 모든 실시간 시장정보 | 불규칙 샘플링 자료 | . | 일중 데이터(Intraday Data) 분봉 시고저종 | 분단위 샘플링 틱 데이터 | . | 일간 데이터(Daily Data) 일봉 시고저종 | 일단위 통계/분석 자료 | . | 시장정보 데이터베이스 &amp; API . 데이터의 종류가 다양해서 데이터베이스의 종류도 다양. 3가지 종류의 데이터베이스 시스템. . 인메모리 디비 : 틱데이터 실시간 처리. 레디스. | HDF5 : 과거 틱 데이터 저장. | MongoDB : 분봉, 분석 데이터 등. 틱 데이터는 실시간으로 message-oriented middleware를 통해 전송되고 다른 데이터들은 각각의 타입에 따라서 api를 만들어 놓음. | 시장 정보 API . 시장 정보 종류별 데이터베이스 클래스 지원 | 모든 시장정보는 pandas DataFrame 형식으로 출력 TickDb Class : In-Memory Database에 저장된 당일의 실시간 틱 데이터 | HistoricalTickDb Class : HDF5 Database에 저장된 과거 틱 데이터 | DailyDb 클래스 : MongoDB에 저장된 당일 및 과거의 시장 분석 데이터 | | . TickDb Class . method - 기능 순 code_st() : 주식 종목정보 code_fo() : 선물옵션 종목정보 code_id() : 지수 종목정보 code_br() : 거래원 정보 ticker_st() : 주식 티커 목록 ticker_fo() : 선물옵션 티커 목록 isin_st() : 주식 isin 목록 isin_fo() : 선물옵션 isin 목록 is_in_ticker_st() : 주식티커 확인 is_in_ticker_fo() : 선물옵션 티커 확인 is_in_isin_st() : 주식 isin 확인 is_in_isin_fo() : 선물옵션 isin 확인 isin2inst() : isin-종목유형 변환 isin2ticker() : isin-ticker 변환 ticker2inst() : ticker-종목유형 변환 ticker2isin() : ticker-isin 변환 get_isin2inst() : isin-종목유형 map get_isin2ticker() : isin-ticker map get_ticker2inst() : ticker-종목유형 map get_ticker2isin() : ticker-isin map session() : 장정보 trade_st() : 주식 체결 틱 히스토리 trade_fo() : 선물옵션 체결 틱 히스토리 quote_st() : 주식 호가 틱 히스토리 quote_fo() : 선물옵션 호가 틱 히스토리 minute_st() : 주식 분봉 히스토리 minute_fo() : 선물옵션 분봉 히스토리 program_st() : 주식 프로그램 매매 히스토리 broker_st() : 주식 거래원 히스토리 index() : 지수 히스토리 list_methods() : 클래스 메소드 목록 list_members() : 클래스 멤버 목록 . HistoricalTickTb Class - 과거 틱 데이터 . 과거 틱데이터 액세스 | TickDb와 동일한 메소드 지원 | 시뮬레이션을 위한 추가 메소드 set_date() : 날짜 지정 set_time() : 시간 지정 | 과거의 특정 시각에 시장을 보는 것과 같은 효과 | . DailyDb Class - 과거 시장 분석 데이터 . 틱 데이터의 분단위 스냅샷 | 분봉 및 일봉 | 시장 모형 기반의 분석 자료 code_st() : 주식 종목정보 code_fo() : 선물옵션 종목정보 code_id() : 지수 종목정보 intraday_st() : 주식의 분단위 스냅샷 데이터 intraday_fo() : 선물옵션의 분단위 스냅샷 데이터 intraday_id() : 지수의 분단위 스냅샷 데이터 daily_st() : 주식의 일단위 데이터 daily_fo() : 선물옵션의 일단위 데이터 daily_id() : 지수의 일단위 데이터 | . Message . Message-Oriented Middleware 기반의 통신 현재 ZeroMQ, Formula 미들웨어 지원 | 복수 미들웨어 동시 사용 가능 | 실시간 시장/주문 정보는 FIX 프로토콜에 기반한 JSON 문자열 | . | 메시지 처리상의 주의점 모든 메시지는 시계열 정보(time series)이므로 병렬처리 불가 | 시장 정보의 경우에는 최신(lastest)의 정보만 처리해야함. 시장 정보 큐(queue)에 복수 정보가 있을 경우 과거 정보 삭제 | . | . 이벤트 기반 전략 . 이벤트 = 실시간 시장 및 주문 정보 | 알고리즘 트레이딩 시스템 = 복합 이벤트 처리 시스템 | . 전략 구현 클래스 라이브러리 . BaseStrategy 베이스 클래스 | Component 클래스 Event | Socket | 원주문(Meta-Order) | 버퍼(Buffer) | 주문(Order) | 체결(Trade) | 포지션(Position) | 종목별 손익(Asset) | 전체 손익(Book) | . | . 이벤트 처리 함수의 구현 방법 . 방법 1 : 전략 클래스의 이벤트 핸들러 메소드 오버라이드 수신되는 이벤트의 유형에 따라 호출되는 이벤트 핸들러 메소드가 미리 정해져 있음. | 특정 이벤트 메소드를 오버라이드 구현하여 원하는 동작 실현 | . | 방법 2 : 이벤트 필터 전략의 상태(Finite State)와 수신 이벤트의 유형의 조합으로 이벤트 핸들러 선택 | 복수의 이벤트 핸들러 수행 가능 | 이벤트 핸들러를 동적으로 추가/제거 가능 | . | . 틱데이터 기반 백테스트(Back-test) . 성능 평가 및 사고 예방을 위한 필수 과정 | 실시간 코드와 동일한 전략 코드로 틱 이벤트 기반의 백테스트 | In-the-Loop 방식이 아닌 시뮬레이션 방식의 백테스트 지원 실제 통신을 하지 않고 직접 이벤트 핸들러 호출 | 테스트 병렬처리, 속도, 배치 프로세싱, 디버그 브레이크 | 타이머 시뮬레이션 가능 backtest_set_datetime() : 백테스트를 시작할 일시 지정 backtest_set_breaktime() : 백테스트를 중지할 일시 지정 backtest_step() : 1개의 이벤트 처리 backtest_go() : 미리 지정한 중지 시점까지 처리 | . | . PEG &amp; LAYERING . Layering : 지정가 주문을 여러 호가에 분할 | Pegging : 호가가 변화하는 경우 최우선 호가로 추종 | .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/algorithm-trading/trading/python/2021/10/19/post006.html",
            "relUrl": "/markdown/algorithm-trading/trading/python/2021/10/19/post006.html",
            "date": " • Oct 19, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "내가 정리하는 트레이딩",
            "content": "트레이딩의 목표 . 유일무이한 목표는 생존이다. 생존과 위험관리는 필요충분조건이다. 따라서 트레이딩의 목표는 위험관리다. 모든 에너지를 위험관리에 집중해야 한다. . 트레이딩도 결국 사업 . 식당 창업을 할 때 기본적으로 분석해야 하는 것이 상권분석, 요식업 트렌드 트렌드 분석 등이다. 마찬가지로 트레이딩을 할 때에는 시장과 자기 자신에 대한 분석을 해야한다. | 요식업에서도 기본을 지키며 고객들에게 최선의 서비스를 제공한다면 성공하리라는 믿음이 있다. 마찬가지로 트레이딩에서도 규율을 지키며 시장과 함께 간다면 장기적으로 성공한다. | 매매 계획과 전략은 요리 레시피와 같다. 레시피가 매번 바뀌지 않듯이 전략은 쉽게 안된다. 전략을 요리라고 생각하자. 요리가 맛있는지 없는지 검증하는 것이 반드시 필요하듯이 전략도 검증 단계를 반드시 거쳐야 한다. | 식당의 목표는 돈을 버는 것이 아닌, 요리의 퀄리티, 즉 맛과 서비스를 고품질로 유지하는 것이다. 마찬가지로 트레이딩의 목표는 시장에서 승리하는 것이 아니라 위험자산을 잘 관리하는 것이다. | 시장이 어떻게 움직일지 미리 예단하지 말것이다. 대신, 구체적인 플랜을 세워 시장의 움직임에 대해 대처하라. 고객의 클레임은 언제 어떻게 나타날 지 모른다. 따라서 항상 기본을 지킨 자세로 대처할 준비를 해야 한다. | . 체크포인트 . 어떤 시장에 진입할 것인가 | 어떤 종목에 진입할 것인가 | 타임프레임은 어느 정도인가 | 언제 진입할 것인가(진입시점) | 어떻게 진입할 것인가(분할매수) | 진입 자본의 크기는 어느 정도인가 | 진입 시 손절 포인트는 언제인가 | 애드업은 언제할 것인가 | 애드업은 얼만큼 할 것인가 | 언제 청산할 것인가(청산시점) | 어떻게 청산할 것인가(분할매도) | 승률은 어떠한가 | 손익비는 어떠한가 | 이익률은 어떠한가 | . 위험관리 . 리스크 관리는 내 욕심을 조절하는 행위다. 리스크와 리턴은 비례한다. 즉 리스크가 클수록 수익도 클 가능성이 높다. 따라서 리스크를 관리하는 것은 기대하는 수익의 크기를 관리하는 것이다. 내가 한 번에 큰 돈을 벌고 싶다면, 그만큼의 큰 위험을 감수하는 것이다. | 리스크 관리의 목적은 시장에서의 생존이다. 생존이 담보된 이후에 꾸준히 이익을 내야 한다. 즉 꾸준이 이익을 내는 수준의 리스크만 부담해야 한다는 것이다. 이 말은 자금 관리가 리스크 관리의 많은 부분을 차지한다는 뜻이다. | 리스크 관리는 자금 관리를 포함한다. 리스크 관리 1 원칙 : 손절매를 철저히 한다. | 리스크 관리 2 원칙 : 베팅 사이즈를 작게 하여 파산 위험을 줄인다. | . | . 매매 전략 . 매매 전략은 크게 2가지 측면이 있다. . 절차적 측면 진입 | 손절매(Stop Loss) | 청산 | . | 범위적 측면 종목만 타겟 ex) 비트코인 선물 | . | 시장 전체 타겟 ex) 업비트 급등코인 단타 | . | . | 깨달음 정리 . 파산 위험은 다음 3가지로 줄일 수 있다. 각각의 매매에 노출되는 베탕 사이즈를 줄인다. | 매매 전략의 승률을 높인다. | 손익비를 높인다. | | 이 중 1번은 자금관리에 관한 것이고 3번은 기대치에 관한 것이다. | 승률은 성공적인 매매에 있어서 크게 중요하지 않다. 다만 트래킹하는 것은 필요하다. | 매매의 성배는 2 가지로 구성된다. 하나는 기대치, 하나는 매매 기회. 기대치는 손익비와 관련이 높다. 매매 전략은 긍정적인 기대치를 갖고 있어야 한다. | 매매 기회는 말 그대로의 매매 기회다. 특정 전략이 아무리 기대치가 좋더라도 매매할 기회가 적다면 무용지물이다. | 따라서 기대치와 매매 기회를 조화시켜야 한다. | . | 검증하기는 TEST 절차를 밟는 것이다. 시스템 트레이딩에선 모의 투자로 진행할 수 있다. | 다만 과거 데이터가 아닌 실시간 데이터로 모의투자를 진행해야 한다. | . 다시 정리 . 각각의 매매에서 노출되는 금전적 리스크를 줄이기 위해 합리적인 자금 관리 규칙을 적용 | 매매 전략의 승률을 개선 | 매매 전략의 평균이익금액/평균손실금액 비율을 개선 | 승률이 아니라 기대칠르 높일 수 있는 매매 전략을 설계 | 매매 기회를 많이 얻을 수 있는 매매 전략을 설계 | 되도록 단순한 매매 전략을 설계 | 잠재적인 지지선과 저항선을 확인할 수 있는 매매 전략을 설계 | 대다수의 투자자가 두려워하고 극소수가 환호하는 곳에서 매매 | 당신의 기대치를 TEST 절차로 검증 | 당신의 기대치를 검증함으로써 신념체계를 만들것 | . 트레이딩 간단하게 나타낸다면? . 손실은 짧게, 이익은 길게 오르는 것 사고 내리는 것 팔고 벌면 늘리고 잃으면 줄이고 . 돈깡의 주식투자 강의 . 1강 . 강 돈을 버는 사람 vs 돈을 잃는 사람 비밀정보나 마법의 기법은 없다. 투자 실력만 있다. 투자 실력은 올바른 방법으로 노력하면 누구나 얻을 수 있다. 강의의 핵심은 공식. 공식을 바탕으로 주식 투자의 방향을 제시하겠다. 공식을 통해 다양한 기법들이 왜 만들어졌고 어떻게 작동하는지 알게 됨. . | 주식투자의 공식 강의의 목표: 공식을 통해 주식 투자의 명확한 방향성 제시 . | 투자 x 복기 = 실력향상 . 실력이 없는 이유는 투자가 아닌 도박을 했고, 복기를 하지 않았기 때문. . 어떻게 투자와 도박을 구별하는가? =&gt; 주식 투자 3단계를 지켜라. | . 종목을 선정하라 | 시나리오를 세워라 | 실행에 옮겨라 | 제대로 복기하는 방법은? =&gt; 강의 후반부 | . 초보자가 반드시 지켜야 할 원칙 | 주식 투자 3단계를 지킨다. 종목 선정, 시나리오, 실행 | 투자의 횟수는 많을수록 좋다. . | 투자 -&gt; 복기 -&gt; 실력향상. 반복 장기투자, 스윙, 데이트레이딩, 스캘핑 등 나에게 맞는 스타일이 있을텐데 투자실력이 증가하면 자연스럽게 만들어짐 . | 복기는 필수다 | 반드시 100만원으로 시작한다. 적은 돈으로 여러 번 투자 경험을 얻는다. | . 2강 . 종목 선정의 공식 매도 세력 &lt; 매수 세력 주가 상승 90%가 집중하는 시그널 : 차트, 재무제표, 기사 10%가 집중하는 시그널 : 트렌드, 이슈 . | 개인투자자를 위한 종목 선정 공식 트렌드 + 이슈 = 상승모멘텀 . | 개인투자자에게 트렌드는 왜 중요한가? 지속성 : 트렌드에 속한 주식이 그렇지 않은 주식보다 더 오래 상승한다. 몇 주 ~ 몇 달 간 지속 상승 | 수익성 : 지속성의 연장선. 오래 지속 상승하기 때문에 수익성이 좋음. 개인투자자는 적은 투자하기 때문에 트렌드에 대해 완벽하게 이해하고 있어야 한다. | . | 개인투자자를 위한 종목 선정 핵심 3가지 개인투자자는 트렌드에 민감해야 한다. | 이슈는 언제나 신선해야 한다. 시장에 처음 등장한 이슈 | 이슈는 투자 타이밍을 결정하는 기준으로 활용한다. 종목 선정은 트렌드와 이슈 모두 고려하고 투자 타이밍은 이슈를 고려 . | . | .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/trading/2021/10/07/post016.html",
            "relUrl": "/markdown/trading/2021/10/07/post016.html",
            "date": " • Oct 7, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "내가 정리하는 트레이딩",
            "content": "트레이딩의 목표 . 유일무이한 목표는 생존이다. 생존과 위험관리는 필요충분조건이다. 따라서 트레이딩의 목표는 위험관리다. 모든 에너지를 위험관리에 집중해야 한다. . 트레이딩도 결국 사업 . 식당 창업을 할 때 기본적으로 분석해야 하는 것이 상권분석, 요식업 트렌드 트렌드 분석 등이다. 마찬가지로 트레이딩을 할 때에는 시장과 자기 자신에 대한 분석을 해야한다. | 요식업에서도 기본을 지키며 고객들에게 최선의 서비스를 제공한다면 성공하리라는 믿음이 있다. 마찬가지로 트레이딩에서도 규율을 지키며 시장과 함께 간다면 장기적으로 성공한다. | 매매 계획과 전략은 요리 레시피와 같다. 레시피가 매번 바뀌지 않듯이 전략은 쉽게 안된다. 전략을 요리라고 생각하자. 요리가 맛있는지 없는지 검증하는 것이 반드시 필요하듯이 전략도 검증 단계를 반드시 거쳐야 한다. | 식당의 목표는 돈을 버는 것이 아닌, 요리의 퀄리티, 즉 맛과 서비스를 고품질로 유지하는 것이다. 마찬가지로 트레이딩의 목표는 시장에서 승리하는 것이 아니라 위험자산을 잘 관리하는 것이다. | 시장이 어떻게 움직일지 미리 예단하지 말것이다. 대신, 구체적인 플랜을 세워 시장의 움직임에 대해 대처하라. 고객의 클레임은 언제 어떻게 나타날 지 모른다. 따라서 항상 기본을 지킨 자세로 대처할 준비를 해야 한다. | . 체크포인트 . 어떤 시장에 진입할 것인가 | 어떤 종목에 진입할 것인가 | 타임프레임은 어느 정도인가 | 언제 진입할 것인가(진입시점) | 어떻게 진입할 것인가(분할매수) | 진입 자본의 크기는 어느 정도인가 | 진입 시 손절 포인트는 언제인가 | 애드업은 언제할 것인가 | 애드업은 얼만큼 할 것인가 | 언제 청산할 것인가(청산시점) | 어떻게 청산할 것인가(분할매도) | 승률은 어떠한가 | 손익비는 어떠한가 | 이익률은 어떠한가 | . 위험관리 . 리스크 관리는 내 욕심을 조절하는 행위다. 리스크와 리턴은 비례한다. 즉 리스크가 클수록 수익도 클 가능성이 높다. 따라서 리스크를 관리하는 것은 기대하는 수익의 크기를 관리하는 것이다. 내가 한 번에 큰 돈을 벌고 싶다면, 그만큼의 큰 위험을 감수하는 것이다. | 리스크 관리의 목적은 시장에서의 생존이다. 생존이 담보된 이후에 꾸준히 이익을 내야 한다. 즉 꾸준이 이익을 내는 수준의 리스크만 부담해야 한다는 것이다. 이 말은 자금 관리가 리스크 관리의 많은 부분을 차지한다는 뜻이다. | 리스크 관리는 자금 관리를 포함한다. 리스크 관리 1 원칙 : 손절매를 철저히 한다. | 리스크 관리 2 원칙 : 베팅 사이즈를 작게 하여 파산 위험을 줄인다. | . | . 매매 전략 . 매매 전략은 크게 2가지 측면이 있다. . 절차적 측면 진입 | 손절매(Stop Loss) | 청산 | . | 범위적 측면 종목만 타겟 ex) 비트코인 선물 | . | 시장 전체 타겟 ex) 업비트 급등코인 단타 | . | . | 깨달음 정리 . 파산 위험은 다음 3가지로 줄일 수 있다. 각각의 매매에 노출되는 베탕 사이즈를 줄인다. | 매매 전략의 승률을 높인다. | 손익비를 높인다. | | 이 중 1번은 자금관리에 관한 것이고 3번은 기대치에 관한 것이다. | 승률은 성공적인 매매에 있어서 크게 중요하지 않다. 다만 트래킹하는 것은 필요하다. | 매매의 성배는 2 가지로 구성된다. 하나는 기대치, 하나는 매매 기회. 기대치는 손익비와 관련이 높다. 매매 전략은 긍정적인 기대치를 갖고 있어야 한다. | 매매 기회는 말 그대로의 매매 기회다. 특정 전략이 아무리 기대치가 좋더라도 매매할 기회가 적다면 무용지물이다. | 따라서 기대치와 매매 기회를 조화시켜야 한다. | . | 검증하기는 TEST 절차를 밟는 것이다. 시스템 트레이딩에선 모의 투자로 진행할 수 있다. | 다만 과거 데이터가 아닌 실시간 데이터로 모의투자를 진행해야 한다. | . 다시 정리 . 각각의 매매에서 노출되는 금전적 리스크를 줄이기 위해 합리적인 자금 관리 규칙을 적용 | 매매 전략의 승률을 개선 | 매매 전략의 평균이익금액/평균손실금액 비율을 개선 | 승률이 아니라 기대칠르 높일 수 있는 매매 전략을 설계 | 매매 기회를 많이 얻을 수 있는 매매 전략을 설계 | 되도록 단순한 매매 전략을 설계 | 잠재적인 지지선과 저항선을 확인할 수 있는 매매 전략을 설계 | 대다수의 투자자가 두려워하고 극소수가 환호하는 곳에서 매매 | 당신의 기대치를 TEST 절차로 검증 | 당신의 기대치를 검증함으로써 신념체계를 만들것 | . 트레이딩 간단하게 나타낸다면? . 손실은 짧게, 이익은 길게 오르는 것 사고 내리는 것 팔고 벌면 늘리고 잃으면 줄이고 .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/trading/2021/10/07/post005.html",
            "relUrl": "/markdown/trading/2021/10/07/post005.html",
            "date": " • Oct 7, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "모닝루틴 및 취침전루틴",
            "content": "Morning Routine . 눈이 떠지면 기지개를 편다. | 잠 기운을 없애기 위해 팔굽혀펴기를 가볍게 20개 한다. | 꿈에 대해 회상해보고 기록한다. | 화장실에 가서 소변을 보고 가글을 한다. | 1분 동안 찬물샤워를 하고 온 몸의 세포를 깨운다. 단, 바디워시는 사용하지 않는다. | 유산균과 함께 물을 한 컵 마신다. | 우유오트밀과 닭가슴살을 먹는다. | 양치를 한다. | 오전 명상을 한다. | 당일의 목표와 해야 할 일 및 하루 계획을 점검한다. | 감사일기를 적는다. | 30분간 독서한다. | 목표를 이룬 모습을 생생하게 상상해본다. | 거울을 보면서 자신감 포즈를 취한다. | 비타민과 영양제를 먹는다. | 오전 운동을 하러 나간다. | Before Bed Routine . 하루의 목표치와 성공 여부를 체크한다. | 잘한 점 및 보완해야할 점, 생각 등을 기록한다. | 내일 해야 할 일들을 정리한다. | 명상을 한다. | 숙면용 소리를 틀고 취침한다. |",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/plan/morning-routine/2021/08/27/post004.html",
            "relUrl": "/markdown/plan/morning-routine/2021/08/27/post004.html",
            "date": " • Aug 27, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "개발 관련 잡다한 팁 모음",
            "content": "Git에서 origin 바꾸기 . git remote set-url origin https://[Personal Access Token]@github.com/sangwon-woo/[repository].git . VS Code Keyboard Shortcut for Mac . 아래에 줄 추가(Insert Line Below): Shift + Command + Enter | 위에 줄 추가(Insert Line Above): Shift + Enter | Delete: fn + Backspace | 단어 하나 왼쪽 삭제(Delete Word Left): Option + Backspace | 단어 하나 오른쪽 삭제(Delete Word Right): fn + Option + Backspace | 왼쪽 끝까지 삭제(Delete All Left): Control + k | 오른쪽 끝가지 삭제(Delete All Right): Control + l | 위에 커서 추가(Add Cursor Above): Option + Command + Upkey | 아래에 커서 추가(Add Cursor Below): Option + Command + Downkey | 터미널 창 토글(View: Togle Panel): Command + j | 위에 줄 복사(Copy Line Up): Shift + Option + Upkey | 아래에 줄 복사(Copy Line Down): Shift + Option + Downkey | 줄 삭제(Delete Line): Shift + Command + k | 마크다운 프리뷰(Markdown: Open Preview to the Side): Command + k v | . Cross Platform Framework . 윈도우, 리눅스와 같은 운영체제에 상관없이 같은 코드로 각 운영체제에서 동작하는 프로그램을 지원하는 것을 의미. . PyQt5 . Qt라는 GUI 프레임워크의 파이썬 바인딩. 키움 Open API+는 OCX(Object Linking and Embedding Custom Control) 방식을 사용하는데, PyQt 패키지의 QAxContainer 모듈을 통해 OCX를 사용. PyQt에서 위젯은 사용자 인터페이스를 구성하는 가장 기본적인 부품 역할을 함. 사용자 인터페이스를 만들기 위해 QGroupBox, QLabel, QTextEdit, QDateEdit, QTimeEdit, QLineEdit와 같은 다양한 위젯이 사용됨. PyQt에서는 다른 위젯에 포함되지 않은 최상위 위젯을 특별히 윈도우(Window)라고 함. PyQt에서 윈도우를 생성하기 위한 클래스로 QMainWindow나 QDialog 클래스가 일반적으로 사용됨. . 이벤트 처리 | . 클래스 변수, 인스턴스 변수 . class Parent: house = &#39;yong-san&#39; # 클래스 변수 def __init__(self): self.money = 10000 # 인스턴스 변수 . 파이썬에서 Sqlite3 사용하기 . import sqlite3 con = sqlite3.connect(&#39;데이터베이스 파일의 경로 및 이름을 지정&#39;) # con이라는 객체를 통해 데이터베이스를 조작 cursor = con.cursor() # 커서는 SQL 구문을 호출 할 때 사용됨 cursor.execute(&#39;SQL 구문을 입력&#39;) # execute 메서드를 사용해서 구문을 호출 cursor.commit() cursor.execute(&#39;SELECT * FROM test_table;&#39;) cursor.fetchall() # 한 번에 모든 로우를 읽기 cursor.fetchone() # 로우 단위로 읽기 cursor.close() # 커서 종료 . pandas DataFrame 객체를 SQLite DB에 저장하기 . import sqlite3 con = sqlite3.connect(&#39;~/test.db&#39;) df = DataFrame(test) df.to_sql(&#39;test&#39;, con) # test라는 이름의 테이블 . 참고로 to_sql은 아래와 같다 . DataFrame.to_sql(name, con, flavor=&#39;sqlite&#39;, schema=None, if_exists=&#39;fail&#39;, index=True, index_label=None, chunksize=None, dtype=None) . name : SQL Table 이름으로 파이썬 문자열 형태로 나타낸다. | con : cursor 객체 | flavor : DBMS를 지정할 수 있다. ‘sqlite’ 또는 ‘mysql’을 사용할 수 있다. 기본값은 ‘sqlite’다. | schema : Schema를 지정할 수 있다. 기본값은 None이다. | if_exists : 데이터베이스에 테이블이 존재할 때 수행 동작을 지정한다. ‘fail’, ‘replace’, ‘append’ 중 하나를 사용할 수 있는데 기본값은 ‘fail’이다. ‘fail’은 데이터베이스에 테이블이 있다면 아무 동작도 수행하지 않는다. ‘replace’는 테이블이 존재하면 기존 테이블을 삭제하고 새로 테이블을 생성한 후 데이터를 삽입한다. ‘append’는 테이블이 존재하면 데이터만 추가한다. | index : DataFrame의 index를 데이터베이스 컬럼에 추가할지 여부를 지정한다. 기본값은 True다. | index_label : 인덱스 컬럼에 대한 라벨을 지정할 수 있다. 기본값은 None이다. | chunksize : 한 번에 써지는 로우의 크기를 정수값으로 지정할 수 있다. 기본값은 None으로 DataFrame 내의 모든 로우가 한 번에 써진다. 많은 로우가 있을 때 데이터베이스 한 번에 쓰는 경우 패킷 크기 제약으로 에러가 발생할 수 있다. 이럴 땐 다음과 같이 하면 된다. | . df.to_sql(&#39;test&#39;, con, chunksize=1000) . dtype : 컬럼에 대한 SQL 타입을 Python Dicktionary로 전달할 수 있다. | . SQLite Table에서 df로 데이터 로드하기 . import pandas as pd import sqlite3 con = sqlite3.connect(&#39;~/~.db&#39;) df = pd.read_sql(&#39;SELECT * FROM kakao&#39;, con, index_col = None) # 또는 index_col = &#39;index&#39; . PyCharm의 디버깅 기능 . Step Over(F8) : 코드의 현재 라인에서 그 다음 라인으로 이동한다. 하이라이트 표시된 라인이 메서드를 호출하고 있어도 다음 줄로 넘어간다. 호출된 메서드는 내부적으로 실행된다. 다만 내부적으로 실행되는 메서드라도 해당 메서드에 breakpoints가 존재할 경우 디버거는 해당 위치에서 정지한다. 이 때 강제로 스킵하고 싶으면 Force Step Over를 사용하면 된다. . | Step Into(F7) : 메서드 내에서 무슨 일이 일어나고 있는지 보여준다. 호출한 메서드가 올바른 결과를 반환하고 있는지 확신할 수 없을 때에 이 기능을 사용해서 메서드 내부를 관찰할 수 있다. . | Step Into My Code(Alt + Shift + F7) : 나의 코드에 집중하고 싶을 때, 라이브러리 클래스로는 stepping 하지 않고 Step Into를 수행하는 기능이다. . | Step Out(Shift + F8) : 메서드를 호출하던 바깥 코드로 빠져나온다. . | . Python GUI . 이벤트 순환문은 GUI를 작동시키는 메커니즘이다. GUI는 이벤트가 전달되기를 기다리는 무한 루프라고 생각할 수 있다. 버튼을 클릭하면 GUI 내부에서 이벤트를 생성하거나 GUI크기를 재조정하는 이벤트를 생성한다. | ttk 모듈에는 GUI를 멋지게 보이게 하는 노북, 프로그레스바, 라벨과 색다른 버튼과 같은 고급 위젯이 있다. 이는 GUI를 더 멋지게 만들어 준다. 어떤 면에서 ttk는 tkinter 패키지 내의 확장이다. | GUI는 이벤트 중심이다. 버튼을 클릭하면 이벤트가 발생한다. ttk.Button 위젯의 command 속성을 사용해 콜백함수에서 이 이벤트가 발생할 때 일어나는 일을 바인드한다. | 클라이언트 코드에 의해 호출되지 않는 비공개 함수임을 나타내기 위해 quit 함수 앞에 밑줄을 하나 붙이는 파이썬 명명규칙을 사용한다. | . import 경로 및 파일 부를 때 경로 . import 할 때는 해당 python script의 디렉터리를 기준으로 부른다. | script 내에서 static file을 읽을 때는 current working directory(os.getcwd()를 보면 됨)를 기준으로 부른다. | . Python Script에서 MySQL 연결하기 . import mysql.connector # create dictionary to hold connection info dbConfig = { &#39;user&#39;: &#39;Pacific&#39;, # your user name &#39;password&#39;: &#39;tkddnjs!1301&#39;, # your password &#39;host&#39;: &#39;127.0.0.1&#39;, } conn = mysql.connector.connect(**dbConfig) print(conn) conn.close() . *args와 **kwargs . *args의 경우 갯수를 알 수 없는 여러 인자를 함수 내부에서 tuple 형태로 받는다. | **kwargs의 경우 갯수를 알 수 없는 ‘키’=’값’ 인자를 함수 내부에서 dictionary 형태로 받는다. | list, tuple type의 변수를 *args를 갖는 함수에 넘겨줄 때는 *list, *tuple 형태로 unpack해서 넘겨줘야 한다. | dictionary type의 변수를 **kwargs를 갖는 함수에 넘겨줄 때는 **dict 형태로 unpack해서 넘겨줘야 한다. | . MySQL . Database | Schema | Table | MySQL에서 데이터베이스랑 스키마랑 동일한 의미. 하지만 다른 DBMS에서는 스키마와 데이터베이스가 동일한 용어가 아님. | . os module . import os fDir = os.path.dirname(__file__) # 현재 실행되는 파일이 속해있는 디렉터리 netDir = fDir + &#39; Backup&#39; if not path.exists(netDir): makedirs(netDir, exist_ok=True) . 요구사항 분석과 시스템 설계 그리고 모델링 . 정보시스템 구축 절차 요약 정보시스템을 구축하기 위해서는 일반적으로 분석, 설계, 구현, 시험, 유지보수의 5가지 단계를 거친다. 분석 단계 - 시스템 분석 또는 요구사항 분석. 우리가 무엇what을 할 것인지 결정. | 설계 단계 - 시스템 설계 또는 프로그램 설계. 우리가 어떻게how 할 것인지 결정. | 구현 단계 - 프로그래머가 설계서에 나온 그대로 프로그램을 작성. | . | . | | 데이터베이스 모델링 데이터베이스 모델링 - 현실세계에서 사용되는 데이터를 MySQL에 어떻게 옮겨 놓을 것인지를 결정하는 과정. | . | | 데이터베이스 구축 절차 데이터베이스 생성 | 테이블 생성 | 데이터 입력 | 데이터 조회/활용 | . | | . 데이터베이스 인스턴스 . Instance는 MySQL 프로그램이 컴퓨터에서 활성화되어 있는 서비스를 말한다. 그래서 일반적으로 MySQL 서버, MySQL 서비스, MySQL 인스턴스 등 모두를 MySQL로 보면 된다. | . 데이터베이스 개체 . Table | Index | View | Sotred Prodecure | Trigger | . vim . i : 입력모드 | h, j, k, l : 좌, 하, 상, 우 | w : 저장 | q : 나가기 | w : 단어나 문장부호 단위로 뛰기(정방향) | W : 띄어쓰기 단위로 뛰기(정방향) | e : 단어끝이나 문장부호 끝 단위로 뛰기(정방향) | E : 띄어쓰기 끝 단위로 뛰기(정방향) | b : 단어나 문장부호 단위로 뛰기(역방향) | B : 띄어쓰기 단위로 뛰기(역방향) | 0 : 해당 라인의 첫 번째 칸으로 가기 | $ : 해당 라인의 끝으로 가기 | ^ : 해당 라인의 첫 글자로 가기 | f 누르고 내가 찾고 싶은 key 입력 : 찾고 싶은 key로 이동 | t 누르고 내가 찾고 싶은 key 입력 : 찾고 싶은 key 앞칸으로 이동 | F, T : 역방향 | ; : 전에 했던 명령어를 수행(f, t를 수행한 후, 정방향) | , : 전에 했던 명령어를 수행(f, t를 수행한 후, 역방향) | / : 찾고자 하는 단어. enter를 누르면 전체 하이라이트. 이 상태에서 n누르면 다음 단어로 이동, N 누르면 다음 단어로 역방향 이동. | *, # : 커서가 위치한 단어를 전체 찾기. | . Mbps, MB, MiB . Mbps = Mega Bit Per Second | 100Mbps = 최대 12MB/S | bps는 1초당 전송할 수 있는 비트의 수를 의미한다. | MB = Megabyte | 10의 6제곱 | 저장매체에서 사용하는 단위. | MiB(메비바이트) = Mebibyte | 1 MiB = 2의 20제곱 = 1,048,576 바이트 | 1TB 저장매체는 대략 931 GiB | . Anaconda 가상환경(base) 자동활성화 해제 . conda activate base (base) conda config --set auto_activate_base false . Anaconda 가상환경에서 mysql connector 설치 및 사용 . pip install mysql-connector-python . import mysql conn = mysql.connector.connect(user=&#39;root&#39;, password=&#39;1234&#39;, host=&#39;127.0.0.1&#39;) . Matplotlib 폰트 설정 및 ‘-‘ 깨짐 설정 . import matplotlib as mpl import matplotlib.pyplot as plt import matplotlib.font_manager as fm mpl.rcParams[&#39;axes.unicode_minus&#39;] = False plt.rcParams[&#39;font.family&#39;] = &#39;NanumBarunGothic&#39; # sorted([(f.name, f.fname) for f in fm.fontManager.ttflist if &#39;Gothic&#39; in f.name]) from IPython.core.interactiveshell import InteractiveShell InteractiveShell.ast_node_interactivity = &#39;all&#39; . 주피터에서 판다스 설정 . import pandas as pd pd.set_option(&#39;display.width&#39;, 5000) pd.set_option(&#39;display.max_columns&#39;, 60) . Producer / Consumer . Producer : 데이터를 queue에 넣는 친구 | Consumer : 데이터를 queue에서 뽑는 친구 | . 객체지향언어의 4가지 특징 . 캡슐화(Encapsulation) | 상속(Inheritance) | 추상화(Abstraction) | 다형성(Polymorphism) | . python multiprocessing . import multiprocessing as mp proc = mp.Process(target=worker, args=(,)) .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/programming/cookbook/tip/software/2021/08/25/post003.html",
            "relUrl": "/markdown/programming/cookbook/tip/software/2021/08/25/post003.html",
            "date": " • Aug 25, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "나만의 명언 목록",
            "content": "나는 책을 좋아한다. 그러다보니 책을 읽다가 마음에 드는 문구나 명언을 여러번 만나곤 한다. 하지만 기록하거나 외운 적이 없어서 1회성 만남으로 그치는 경우가 대다수였다. 운이 좋아 친구들이나 주변 지인들에게 내가 받았던 감명깊은 부분을 전달하면 가끔씩 내 머릿속에 다시금 떠올라올 뿐이었다. 이제는 명언도 기록해야겠다. 내가 좋아한 다는 것은 나의 가치관과 연결되어 있다는 것이니깐. 전반적인 가치관의 틀을 시각화하기 위해서라도 꾸준히 진행해야 할 것임에 틀림없다. . . 생산성이란 더 많은 일을 해내는 것이 아니라 옳은 일을 해내는 것이다. . 마이클 하야트의 초생산성 p.28에 나오는 말이다. 생산성에 대해서 잘못 알고 있었던 부분을 깨닫게 해준 명언이다. . . 더 오래 산다고 죽음을 이기는 것이 아니다. 잘 살고, 꽉찬 삶을 사는 것으로 죽음을 이기는 것이다. . 태어나서 죽기 전까지 무엇을 할 것인가. 죽음은 누구에게나 온다. 죽음은 삶 만큼 흔하다. 그렇다면 내가 죽음을 대하는 태도는? 랜디 교수 말대로 오래 산다고 죽음을 피하는 것이 아니다. 지금 이 순간을 충실하게 가득 채움으로써 죽음을 피할 수 있다. . 후회는 이미 해본 것들에서 오는 것이 아니라 하지 못한 것 때문에 온다. | 물질에서 열정을 찾을 수 없다. | . 21세기의 문맹은 읽고 쓰지 못하는 이들이 아니다. 오히려 배운 것을 원점으로 되돌린 후, 새롭게 배우는 것을 못하는 이들이다. by 앨빈 토플러 . 새롭게 배우지 못하는 사람들이 많다. 스스로가 너무 똑똑하고 아는 것이 많다고 생각해서 발생하는 교만일까. 아니면 단순히 호기심이 부족해서 그런 것일까. 무엇이든지 간에 새로운 것에 대해 배우고자 하는 마음이 없다면 남은 미래는 안봐도 뻔하다. . 인생은 권태와 욕망 사이를 흔들리는 시계추와 같다. . 쇼펜하우어가 한 말이다. 이보다 인생을 잘 설명한 것은 없는 듯 하다. 많은 사람들이 권태를 참을 수 없어 한다. 나도 그러하다. 가만히 있으면 뭔가 뒤쳐지는 것 같았고 삶이 무료해서 뭐라도 해야할 것만 같았다. 하지만 버트런트 러셀은 권태와 조화로운 관계를 유지하라고 권했다. 권태는 생각보다 우리의 삶에 일상적으로 존재하기 때문이다. 그리고 권태 속에서 커다란 가치가 탄생한 역사적 일화도 많이 소개해줬다. 나도 놀고 싶은 것을 참고 해야할 일을 더 많이 해야겠다. .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/self-development/maxim/golden-saying/2021/08/17/post002.html",
            "relUrl": "/markdown/self-development/maxim/golden-saying/2021/08/17/post002.html",
            "date": " • Aug 17, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "간단한 생각",
            "content": "2021-08-14 . 나의 목표 : 나의 목표는 무엇일까. | 나는 어떻게 살아야 하지? 앞으로 무엇을 하면서 살아야 할까. | 나의 먼 미래는 어떤 모습일까. | 나에게 지금 당장 필요한 것은 무엇일까 | 지금 당장 해야하는 가장 중요한 일은 무엇일까. | 먼 미래의 죽기 직전의 내가 지금의 나로 환생했다고 가정하자. 모든 기억은 없지만 내가 환생했다는 사실만 안다고 해보는 거다. 그렇다면 내가 지금처럼 행동하면서 살까? | 나에게 계획은 없었다. 그냥저냥 살아왔던 것인데.. 나의 목표와 이를 이루기 위한 계획을 세워야 한다. | 근본부터 다시. 내가 생각하는 나만의 프레임을 만들어야겠다. 나만의 운영체제. 신념과 가치관. | 계획을 잘 세워보자. 어떻게? | 나는 정말 무엇을 원하는가? 단순히 돈을 많이 벌고 싶은걸까? 아니면 돈을 벌고 난 뒤의 뭔가를 원하는 것일까. | 세상에는 단 하나의 진실된 약속이 존재한다. 언젠가는 죽는다는 것. 죽음은 별로 두렵지는 않다. 언젠가 마주해야 할 순간이 반드시 올 것임을 알고 있기 때문이다. | 내가 정말 잘 하고 싶은 것은 알고리즘 트레이딩이다. 알고리즘 트레이딩은 프로그래밍과 트레이딩 기법이 심리싸움이 녹아있어야 한다. | 깊게 생각해보고 판단해보자. 사실 지금까지 나 혼자의 사고로 깊게 생각해본적은 많이 없다. 깊게 정말 깊게 고민하는 활동을 해보자. | . 2021-08-15 . 정말 중요한 것 무엇보다도 가족과 연인, 친구, 동료. 결국 내사람들. . 건강(육체적 측면) 음식 식단 | 영양제 | . | 운동 러닝 | 라이딩 | 등산 | 헬스 | 스트레칭(유연성 증대) | . | . | 건강(정신적 측면) 명상 | 일기 | 독서 | 사색 | . | 마인드셋(Mindset) | 동기부여(Motivation) | 방법(Method) | 계획(Plan) | 2021-08-26 . 그냥 하고 싶은 일에 깊게 몰두하고, 나머지 것들은 차단해버리는 게 속 편할 듯. 우선 알고리즘 트레이딩 시스템을 닥치는 대로 만들어보자. 이미 기성세대들이 오프라인을 장악했다. 내가 집중해야 하는 곳은 새로운 시장이다. 앞으로 뜰 거 같은.. 행복의 4중주 - 엔돌핀, 세로토닌, 도파민, 옥시토신 . 2021-08-31 . 오늘 잠실M타워 1214호 계약 이제 남은 것은 이전 사무실에서 책과 컴퓨터와 모니터를 가져오는 것. 주말동안 짐을 좀 갖다놓아야겠다. . 책을 읽을수록, 유투브를 볼수록 뭔가 바보가 되는 느낌. 모두 그들의 삶. 그 속에서 타산지석으로 삼아야 하는 것을 발견해야 하지만 그 전에 나는 어떤 것을 원하는지 정의하는 게 우선일듯. 나는 어떤 삶을 살고 싶은것일까. 단순히 돈이 많이 생기면 그게 다일까? 이 세상에 어떤 도움이 되고 싶은 걸까. 가치를 창출하는 것. 창작하는 것. 새로운 것을 만들어내는 것. 하지만 다른 사람들에게 도움이 되는 것. 장기적인 안목으로 내 삶을 바라보면 당장의 걱정거리는 별로 필요없다. 나침반을 만들어야 한다. 내 길을 내가 찾아야 한다. 체면(Saving Face)을 살리는 걸 당연하다고 생각하지 말자. 나는 무엇을 위해 지금까지 이렇게 살아왔는가. 곰곰히 생각해보면 대부분 체면치레였다. 내가 진정 원했던 것은 아니었어. 내가 진짜 해보고싶고, 진짜 원하는 것은.. . 2021-09-05 . 삶의 의미는 가족이다. 가족이라 함은 나의 가족이 건강하고 행복한 삶을 영위하도록 최대한 돕는다는 것을 의미한다. 이것에는 나의 삶의 태도와 방향이 담겨 있다. 다만 가족이 있기 위해선 내가 먼저 있어야 한다. 그것은 양보할 수 없는 진실이다. 그렇다면 여기에 나는 있는가. 삶의 의미를 내 속이 아닌 내 밖에서 찾은 것 아닌가. 또한 언젠간 이별이 있을텐데 그 이후의 삶의 의미는 무엇이겠는가. 아직은 잘 모르겠다. 하지만 이것을 영원불변하는 삶의 기준으로 꼭 가져가야 하는 법도 없다. 그저 현재 내 상황과 현실에 맞게 내 삶의 의미를 찾았을 뿐이다. 남은 것은 빠르게 돈을 버는 것이다. 돈 보다 중요한 것은 시간이고, 시간보다 중요한 것은 나의 집중력이기 때문에 쓸 데 없는 것에 내 주의를 빼앗기지 말자. 내가 지금 해야 할 일과 앞으로 해야 할 것 외에 다른 것에 신경을 돌리는 것은 가족에게 해를 끼치는 행동이라고 여기자. 사실 나도 알고 있다. 나는 굉장히 외부의 영향을 많이 받는 사람이라는 것을. 이제는 인정하고 더 이상 고민하지 말고 해야 할 일에 집중하자. . 2021-09-06 . 오늘은 사무실 이사를 하는 날이다. 앞으로 무엇을 해야 하는가. . 교대 사무실에 있는 모든 짐들을 종합운동장 사무실로 옮긴다. | 종합운동장 사무실의 크기를 실측한다. 데스크 및 책장 등을 고려해서 구조를 생각해본다. 접이식매트리스 | 온수매트리스 | 블라인드 | 식사용 테이블 | 화이트보드 | . | 영등포 집에 있는 개발, 컴퓨터, 트레이딩, 투자 관련 서적을 종합운동장 사무실로 옮긴다. | 송파구로 전입신고를 한다. | 오금역 근처에 있는 퍼시스 매장으로 간다. | 사무용 데스크를 구매한다. | 2021-09-10 . 사람들이 명품을 사는 이유는 과시욕일 수도 있으나 사실은 더 깊은 내면의 무엇인가가 있는 듯 보인다. 신세계 백화점 강남점을 가보니 명품으로 치장한 수 많은 사람들을 볼 수 있었다. 물론 대다수는 여성이었다. 왜 그들은 백화점에 명품을 치장하고 나타날까? 이들은 백화점이 아닌 곳에서도 명품을 입고 다닐까? 백화점은 이제 그들의 런웨이가 되었다. 백화점에선 명품이 없으면 소외된다. 그들 무리에 끼려면 명품을 살 수 밖에 없는 것이다. 그렇다면 왜 백화점이 그들의 런웨이로 변했을까. 백화점이 어떤 신호를 보내는 것일까. 요즘 백화점, 특히 명품관을 가보면 굉장히 고급스럽다는 느낌이 든다. 인테리어도 예쁘고 시설도 깔끔하다. 백화점 명품관은 하나의 놀이터가 된 것이다. 다만 굉장히 고급스럽고 기품있는 곳이라는 신호를 사람들에게 보내는 것이다. 사람들도 이 신호에 맞춰서 다른 사람들에게 신호를 보낸다. 특히 한국처럼 체면을 중시하는 곳에서는 더욱 이런 신호가 크게 느껴진다. 눈으로 보여지는 것으로 사람을 판단하는 대한민국은 하이엔드 신호에 민감하게 반응할 수밖에 없는 곳이다. 물론 대한민국 모든 곳에서 이렇지 않다. 어느 정도 소비력을 갖춘 사람들이 사는 동네의 백화점이 유독 심할 뿐이다. 이런 모습을 보고 있으면 모두가 외로워하는 듯해 보인다. 명품으로 치장을 해서라도 눈에 보이지 않는 추상적인 신호를 백화점 내의 다른 사람들에게 보냄으로써 그들과 같은 무리임을 증명하려고 애쓰는 것 같다. 사람들은 자기만족이라고 하겠지만 사실 어떤 추상적 명품 무리에 속하기 위함임을 스스로도 알고 있을 것이다. 나는 뒤쳐지지 않았다는 것을 신호로 내뿜고 싶을 것이다. 못 사는 동네의 백화점은 어떨까. 혹은 잘 사는 동네의 백화점이 아닌 종합쇼핑몰 같은 곳은 어떨까. 그곳도 명품으로 치장한 사람들이 많을까? . 2021-09-13 . 두 가지의 삶 . 첫 번째 삶은 행복하게 이 순간을 즐기는 삶 두 번재 삶은 하나의 목표만을 향해 달려가는 몰입감 높은 삶 . 2021-09-14 . 매슬로의 동기이론 . 1 단계 . 생리적 욕구로 의식주 생활에 관한 욕구, 즉 본능적인 욕구를 의미 . 2 단계 . 안전의 욕구로 사람들이 신체적 및 정서적으로 안전을 추구하는 욕구를 의미 . 3 단계 . 소속감과 애정의 욕구로 어떤 단체에 소속되어 소속감을 느끼고 주위사람들에게 사랑받고 있음 느끼고자 하는 욕구 . 4 단계 . 존경의 욕구로 타인에게 인정받고자 하는 욕구 . 5 단계 . 자아실현의 욕구로 가장 높은 단계의 욕구로서 자기만족을 느끼는 단계 . 2021-09-21 . 동기부여의 종류 . 첫 번째 동기부여는 외부에서 오는 동기부여 대표적으로 체면지키기 부모님에게 자랑스러운 아들되기, 남 부끄럽지 않은 직업 갖기, 친구들에게 꿀리지 않기 등 다양한 동기부여의 원천이 존재한다. 매슬로의 동기이론에서 4단계 욕구에 해당. 즉 타인에게 인정받고자 하는 욕구. 두 번째 동기부여는 내부에서 오는 동기부여 자신이 진짜 하고 싶은 일이 무엇인지 아는 사람들이 하는 것 남들의 시선에서 비교적 자유롭다. 그리고 큰 위험 또는 시련에 흔들리지 않고 버틸 수 있다. 매슬로의 동기이론에서 5단계 욕구에 해당. 즉 자기만족을 위한 욕구. 동기이론에 의하면 고차원의 욕구와 저차원의 욕구로 나뉘어 있어 자칫하면 우열로 보일 수 있으나 모든 욕구는 동일하게 가치가 있음. 고로 아직 자기가 높은 차원의 동기부여가 아니더라도 방황하지 않고 자신의 본심을 인정하고 앞으로 해야 할 일에 집중하면 될 뿐임. . 2021-09-23 . 사무실로 짐 옮기기 . 큰 책장 3개 | 작은 책장 2개 | 도서 약 700여 권 | 사무용 의자 1개 | 프린터 1개 | 공기청정기 1개 | 아령 24kg 2개 | 커피포트 | . 2021-09-30 . 직렬과 병렬 . 우리의 에너지는 직렬로 작용한다. 반면에 인생은 병렬적이다. 다면적이다. 입체적이다. 이 둘 사이에는 항상 간극이 존재하고 이 때문에 우리는 괴로워한다. 그래도 어느 정도 괴로움을 줄일 수 있는 방법이 있다. 인생의 여러 측면 중 일부를 습관으로 커버하는 것이다. 가령 건강이라는 인생의 정말 중요한 이슈를 생각해보자. 건강한 삶을 위해선 여러 가지가 필요하다. 대표적으로 식습관과 운동이 있다. 여기에 정신 건강은 예외로 두자. 식습관은 좋은 음식을 적절한 양으로 꾸준히 먹는 것을 의미한다. 하지만 좋은 음식을 만드는 것은 귀찮고 어려운 일이다. 운동도 마찬가지로 좋은 운동을 적절하게 꾸준히 해야 한다. 하지만 좋은 운동을 꾸준히 하는 것도 귀찮고 어렵다. 만약에 식습관과 운동 모두 신경쓰기 시작한다면 분명히 우리가 매일 사용할 수 있는 에너지의 많은 부분이 이 둘에게 할당될 것이다. 그러던 와중에 만약 다른 큰 문제가 발생하면? 인생은 예상치 못한 문제를 꾸준히 던져주기 때문에 항상 이를 대비하기 위해 여분의 에너지를 남겨둘 수 밖에 없다. 그러다보니 운동과 식습관, 문제 해결 등 다양한 일을 효과적으로 처리하지 못하고 허둥지둥 되는 상황도 종종 발생한다. 내가 그러한 삶을 살아왔기 때문에 더욱 나에게 와닿는 깨달음이었다. 고로 식습관과 운동을 습관화한다면 이는 어느 정도 커버할 수 있겠다는 생각이 들었다. 습관을 잘 들이기 위해선 어떻게 해야할지는 논외로 하자. 하지만 이제 내가 몰입을 해야 하는 일을 해야 하는 시점이기에 식습관과 운동을 반드시 습관화해야겠다. 나도 놀고 싶다. 하지만 지금은 놀 때가 아니다. . 2021-11-30 . 위험과 기회 . 벌써 11월 마지막 날이다. 퇴사를 하고 알고리즘 트레이딩 시스템을 개발하는 일을 시작한지도 어느덧 몇 개월이 흘렀다. 이제 아버지도 어느 정도 믿고 일을 맏기시려는 것 같다. 위험과 기회를 모두 인지하셔서 그런 듯하다. 아버지에겐 퇴사는 곧 위험일 뿐 기회는 존재하지 않은 행위였다. 하지만 주변 분들의 여러 이야기를 듣고 최근 세상이 돌아가는 것을 보시다보니 기회도 존재함을 알게 되신 것 같다. 반면 나는 위험을 인지하지 않고 기회만 보고 퇴사를 한 케이스다. 이제는 위험도 인지하고 있다. 그러기에 더욱 열심히 일할 수밖에 없는 상황이다. 여러모로 나한텐 도움이 되고 있다. . 2021-12-16 . 인생도 투자처럼 . 트레이딩의 목표는 돈을 버는 것이 되면 안된다. 트레이딩의 목표는 생존이 되어야 한다. 만약 트레이더가 꾸준히 시장에 참여하며 트레이딩하는 와중에 오랫동안 생존해 있다면 그는 반드시 돈을 벌고 있는 상황이다. 즉 생존이 목표고 수익은 논리적으로 귀결되는 부산물일 뿐이다. 이를 위해 트레이딩에는 다양한 위험관리 기법이 존재하는 것이다. 자금관리 기법도 파산을 피하는 가장 좋은 도구 중 하나다. 최근 읽은 책들을 살펴보면 인생도 이와 비슷하게 목표를 설정할 수 있을 것 같다는 생각이 들었다. 돈을 벌어서 젊은 나이에 은퇴하여 남은 인생을 편안하게 사는 것을 목표로 했었다. 즉 파이어족이 되는 것이 목표였다. 하지만 이는 무엇인가 트레이딩에서 돈을 목표로 하는 것과 비슷하다고 느껴졌다. 트레이딩에서의 제1목표가 생존이면 인생의 제1목표는 무엇인가. 인생의 제1목표는 생존이 되면 안된다. 물론 생존이 쉬운 것은 아니다. 생존이 목표가 안될 이유도 딱히 없다. 다만 내가 처한 객관적인 현실과 환경을 고려했을 때 내가 생존 하는 것은 그닥 어려운 일은 아니다. 말 그대로 숨만 붙어 있으면 생존은 하는 것이기 때문이다. 나에게 있어서 인생의 제1목표는 발전이라고 말하고 싶다. 발전은 어제보다 나은 나를 의미한다. 내가 발전하고 있다면 생존은 부산물일테고 돈도 부산물일 것이다. 그렇다면 발전은 어떻게 할 수 있을까? 가장 처음 인정해야 하는 것은 나의 인식의 한계다. 세상은 너무나도 복잡하고, 나에게 주어진 정보는 한정적이다. 내가 느끼는 세상은 절대 진리가 아니다. 따라서 의사결정을 베팅처럼 느끼고, reflexity를 인지하면서 살아가야 한다. 나의 믿음과 인식을 꾸준히 정교화 시켜야 한다. . 2021-12-19 . 옛날에 써 놓은 메모들 . 공부는 모르던 주제에 대해 익숙해지는 것이고 대가가 된다는 것은 어떤 주제에 대해 스토리 텔러가 된다는 뜻이다. 감회부터 떠오른다면 그 사람은 진짜 그 일을 한 것이다. 이걸 내가 적은 것인지 아니면 다른 곳에서 본 글귀를 받아 쓴 것인지 기억이 안난다. 아마 전자에 가깝지 않을까 싶다. 훗날 내가 현재를 돌이켜 볼 때 감회부터 떠오르면 지금 내 일을 난 제대로 한 것이겠지. 그렇다면 앞으로 무엇을 해야할까? 도서 ‘결정’에서 보면 긍정적 상상과 부정적 상상 모두 필요하지만 어떤 일을 성취함에 있어서 부정적 상상이 더 효과적이라고 했다. 즉 나의 멀지 않은 미래 시점에서 현재 일을 돌이켜보며 내가 하고자 하는 일이 잘 안될 수 있다면 어떤 부분일지 생각해보는 것이다. 내가 하고자 하는 일은 주식과 코인에 대해서 알고리즘 트레이딩 시스템을 구축하는 것이다. 그리고 1차 목표는 주식과 코인 전 종목에 대해 추세추종 매매를 하는 것이다. 그럼 추세추종 매매를 하는 자동화된 시스템을 만들기만 하면 우선 목표를 이루는 것 아닌가? 목표는 정해졌다. 이제 추세추종매매 전략만 짜보자. | . 2021-12-25 . 크리스마스 . 메인 프로세스에는 데이터 저장 기능을 넣고 서브 프로세스에 웹소켓으로 데이터를 받는 기능을 넣어서 돌려보자. . 2022-01-05 . 할아버지 제사 . 어머니 환갑 생신 및 할아버지 기일이다. . 2022-01-13 . 해야 할 것들 . 여행에 필요한 짐 싸기 | 로션, 선크림, 아이크림 | 타이레놀, 비타민 | 샴푸, 헤어에센스, 헤어크림, 헤어부스터 | 니트 2벌 | 목도리 1개 | . 음식점 리스트 만들기 | 판다스 쿡북 익히기 | 여러가지 파생지표 만들 때 사용 | 1분봉을 1시간봉, 4시간봉 등으로 만들 때 사용 | 추세 확인 때 사용 | . 홈페이지 제작 관련 인프런 강의 듣기 | 시각화 기술 관련 인프런 강의 듣기 | 클래스 101 강의 듣기 |",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/plan/roadmap/2021/08/14/post001.html",
            "relUrl": "/markdown/plan/roadmap/2021/08/14/post001.html",
            "date": " • Aug 14, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hi! My name is Sangwon Woo. . I’m a software developer and system trader. . Currently, I’m working with my friend. .",
          "url": "https://sangwon-woo.github.io/dailyblog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://sangwon-woo.github.io/dailyblog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}