{
  
    
        "post0": {
            "title": "Pandas Cookbook 2ed",
            "content": "1장 판다스 기초 . 판다스 임포트 . import pandas as pd import numpy as np . 데이터 프레임에서 단일 열을 선택하면 결과는 시리즈(1차원 데이터셋)으로 반환된다. 많은 시리즈 메서드가 반환하는 출력은 시리즈다. . 판다스 데이터프레임 해부하기 . 데이터프레임은 인덱스(index), 열(columns), 데이터(data)라는 세 가지 구성요소가 있다. . pd.set_option(&#39;max_columns&#39;, 40, &#39;max_rows&#39;, 10) movies = pd.read_csv(&#39;../data/movie.csv&#39;) movies.head() . 열과 인덱스를 통칭해 축이라고 한다. 인덱스는 축 0번이고 열은 축 1번이다. 판다스는 NaN(Not a Number)을 사용해 결측치를 나타낸다. . 데이터프레임 속성 . 일반적으로 데이터를 넘파이 배열로 가져올 수 있지만 모든 열이 수치가 아닌 이상 데이터프레임에 그대로 둔다. 데이터프레임은 열들의 데이터 형식이 서로 다른 경우를 관리하는 데 이상적이지만 넘파이 배열은 그렇지 않다. . columns = movies.columns index = movies.index data = movies.values . 인덱스의 타입은 pandas.core.indexes.range.RangeIndex 컬럼의 타입은 pandas.core.indexes.base.Index 데이터의 타입은 numpy.ndarray 인덱스와 열은 둘 다 Index의 서브클래스이다. 판다스에는 여러 형식의 인덱스 객체가 있다. 인덱스를 지정하지 않으면 판다스는 RangeIndex를 사용한다. 전체 값은 필요할 때까지 메모리에 로드되지 않으므로 메모리가 절약된다. . index.values columns.values . 판다스의 대부분은 ndarray에 크게 의존한다. 인덱스, 열, 데이터의 이면에는 넘파이 ndarray가 있다. . 데이터 형식 이해 . 데이터는 연속형과 범주형으로 크게 분류할 수 있다. . float : 넘파이 부동소수점수 형식으로 결측치를 지원한다. | int : 넘파이 정수 형식으로 결측치를 지원하지 않는다. | ‘Int64’ : Null 값을 지원하는 판다스 정수 형식이다. | object : 문자열(과 혼합형식)을 저장하는 넘파이 형식이다. | ‘category’ : 판다스 범주형으로, 결측치를 지원한다. | bool : 넘파이 불리언 형식으로 결측치를 지원하지 않는다.(None은 False, np.nan은 True로 취급) | ‘boolean’ : Null 값을 지원하는 판다스 불리언 형식이다. | datetime64[ns] : 넘파이 날짜 형식으로 결측치(NaT)를 지원한다. | . movies.dtypes # Series movies.dtypes.value_counts() # Series moives.info() # None Type . 데이터프레임의 각 열별로 하나의 데이터 형식이 나열된다. 판다스는 데이터를 표현하기 위한 적정 메모리 용량과 상관없이 핵심 수치 형식인 정수와 부동소수점수를 나타내는 데 64비트를 사용한다. 열 전체가 정수 0으로만 구성돼 있더라도 여전히 데이터 형식인 int64인 것이다. .value_counts 메서드가 .dtypes 속성에서 호출되면 데이터프레임의 모든 데이터 형식의 개수를 반환한다. object 데이터 형식으로 된 열은 유효한 모든 파이썬 객체를 포함할 수 있다. info 메서드는 null이 아닌 값의 개수와 함께 데이터 형식 정보를 출력한다. 또한 데이터프레임에서 사용된 메모리 크기가 나열된다. 카테고리 형식은 가능한 가지수로만 이뤄진 고정 개수의 문자열을 처리하고자 만들어졌다. . 열 선택 . 데이터 프레임에서 단일 열을 선택하면 시리즈가 반환된다. 이 시리즈는 1차원 데이터로 인덱스와 데이터로만 구성된다. . movies[&#39;director_name&#39;] # Series movies.director_name # Series movies.loc[:, &#39;director_name&#39;] # Series movies.iloc[:, 1] # Series movies[&#39;director_name&#39;].index movies[&#39;director_name&#39;].dtype movies[&#39;director_name&#39;].size movies[&#39;director_name&#39;].name movies[&#39;director_name&#39;].apply(type).unique() . 시리즈를 추출하는 데 다양한 방법이 있다. .loc와 .iloc 속성을 사용할 수도 있다. 전자는 열 이름을 끄집어내는 데 사용할 수 있고, 후자는 위치로 지정한다. 판다스 문서상에서 이 둘은 각각 ‘라벨 기반’과 ‘위치 기반’으로 부른다. .loc의 사용법은 콤마(,)를 사용해 행과 열 모두를 지정하는 것이다. .iloc도 행과 열 선택자를 모두 선택한다. 적절한 속성을 사용하면 시리즈의 인덱스, 형식, 길이, 이름도 볼 수 있다. .unique 메서드를 체인시켜 director_name 열 중에서 고유한 형식만 살펴볼 수 있다. . 판다스 데이터프레임은 대게 여러 개의 열을 가진다. 각 열은 시리즈 형태로 끄집어내 사용할 수 있다. 인덱스 연산자(‘[]’)를 사용하면 어떤 열 이름도 사용할 수 있다. . 시리즈 메서드 호출 . 시리즈가 가진 모든 속성과 메서드를 찾아보려면 내장된 dir함수를 사용하면 된다. 다음 코드는 시리즈와 데이터프레임에서 공통적인 속성과 메서드 개수를 보여준다. 이 두 객체는 상당수의 속성과 메서드 이름을 공유한다. . s_attr_methods = set(dir(pd.Series)) len(s_attr_methods) df_attr_methods = set(dir(pd.DataFrame)) len(df_attr_methods) len(s_attr_methods &amp; df_attr_methods) . movies = pd.read_csv(&#39;../data/movie.csv&#39;) director = movies[&#39;director_name&#39;] fb_likes = movies[&#39;actor_1_facebook_likes&#39;] director.sample(n=5, random_state=42) director.shape director.unique() director.count() fb_likes.quantile() fb_likes.min() fb_likes.max() fb_likes.mean() fb_likes.median() fb_likes.std() fb_likes.describe() fb_likes.quantile(.2) fb_likes.quantile([.1, .2, .3, .4, .5, .6, .7, .8, .9]) director.isna() fb_likes_filled = fb_likes.fillna(0) fb_likes_filled.count() fb_likes_dropped = fb_likes.dropna() fb_likes_dropped.size . 일반적으로 시리즈의 데이터 형식에 따라 가장 유용한 메서드가 달라진다. 예를 들어 object 데이터 형식의 시리즈에 가장 유용한 메서드 중 하나는 빈도를 계산하는 .value_counts()다. 시리즈의 원소 개수는 .size나 .shape 속성이나 내장된 len 함수를 사용해 계산할 수 있다. .unique() 메서드는 고유한 원소를 담은 넘파이 배열을 반환한다. .count() 메서드는 결측치가 아닌 아이템 개수를 반환한다. .min(), .max(), .mean(), .median(), .std() 등의 기본적 통계량도 제공된다. .describe() 메서드를 사용해 요약 통계량과 함께 몇 가지 분위수를 동시에 표현할 수 있다. 다만 object 데이터 형식의 열에 적용하면 완전히 다른 출력이 반환된다. .quantile() 메서드는 수치 데이터의 분위수를 계산한다. 입력이 스칼라면 출력도 스칼라지만 입력이 리스트면 출력은 시리즈다. .isna() 메서드를 사용하면 각 개별 값의 결측치 여부를 알 수 있다. 결과는 불리언 배열 시리즈다. .fillna() 메서드를 사용하면 시리즈 내의 모든 결측치를 다른 값으로 대체할 수 있다. .dropna() 메서드를 사용하면 시리즈 내의 결측치를 제거한다. 각 메서드에서 반환되는 객체들은 형식이 서로 다르다. .value_counts() 메서드는 가장 유익한 시리즈 메서드 중 하나다. 기본 설정으로는 개수를 반환하지만 normalize 매개변수를 True로 설정하면 개수 대신 상대빈도값이 반환된다. . director.value_counts(normalize=True) director.hasnans director.notna() . .hasnans 속성으로 결측치 여부를 검사할 수 있다. .notna() 메서드는 결측치가 아닌 모든 값에 대해 True를 반환한다. . 시리즈 연산 . movies = pd.read_csv(&#39;../data/movie.csv&#39;) imdb_score = movies[&#39;imdb_score&#39;] imdb_score + 1 imdb_score * 2.5 imdb_score // 7 imdb_score &gt; 7 director = movies[&#39;director_name&#39;] director == &#39;James Cameron&#39; imdb_score.add(1) # imdb_score + 1 imdb_score.gt(7) # imdb_score &gt; 7 . 뺄셈, 곱셈, 나눗셈, 지수와 같은 기본 산술 연산자도 스칼라 값과 유사하게 작동한다. 파이썬에서 //는 몫을 구하는 나눗셈 연산이다. 이 연산은 결과를 내림한다. % 기호는 나머지를 구하는 연산으로, 나눗셈을 하고 난 나머지를 반환한다. 시리즈 인스턴스는 이 연산들을 지원한다. 6개의 비교연산자도 존재하는데 각 비교연산자는 각 조건 결과에 기반을 두고 시리즈 각 값에 대해 True나 False를 반환한다. 결과는 불리언 배열이며, 필터링에서 매우 유용하게 쓰인다. 모든 연산자에는 동일한 결과를 생성하는 메서드가 있다. 연산자 대신 메서드를 사용하면 메서드를 체인시킬 때 유용하다. 연산자로 뺄셈을 하면 결측치가 무시된다. 그러나 .sub() 메서드를 사용하면 결측치 대신 사용할 fill_value 매게변수를 지정할 수 있다. . +, -, *, /, //, %, ** : .add(), .sub(), .mul(), .div(), .floordiv(), .mod(), .pow() | &lt;, &gt;, &lt;=, &gt;=, ==, != : .lt(), .gt(), .le(), .ge(), .eq(), .ne() 특정 시리즈의 각 요소에 2.5를 곱해야 한다는 것을 파이썬은 어떻게 알 수 있을까? 파이썬의 객체는 특수 메서드를 사용해 연산자와 통신할 수 있는 표준화된 내장방법을 갖고 있다. 특수 메서드는 객체가 연산자를 만날 때마다 내부적으로 호출된다. 특수 메서드는 항상 밑줄 두 개로 시작하고 끝난다. 따라서 던더 메서드라고도 한다. 파이썬은 imdb_score * 2.5 표현식을 imdb_score.mul(2.5)로 해석한다. 참고로 .mul() 메서드를 호출하는 것은 .mul() 메서드를 호출하는 것과 다르다. | . 시리즈 메서드 체인 . 파이썬에서 모든 변수는 객체를 참조하며, 여러 속성과 메서드는 새로운 객체를 반환한다. 이 덕분에 속성 접근을 사용해 메서드를 연속으로 호출할 수 있다. 이러한 방법을 메서드 체인 또는 플로우 프로그래밍이라 부른다. . movies = pd.read_csv(&#39;../data/movie.csv&#39;) fb_likes = movies[&#39;actor_1_facebook_likes&#39;] director = movies[&#39;director_name&#39;] director.value_counts().head(3) fb_likes.isna().sum() fb_likes.dtype (fb_likes.fillna(0) .astype(int) .head() ) . 체인 끝에 추가되는 가장 흔한 두 가지 메서드는 .head()나 .sample()이다. 결측치의 개수를 알아내는 일반적인 방법은 .isna()를 호출한 후 .sum()메서드를 체인시키는 것이다. .astype() 메서드를 사용해 데이터 타입을 바꿀 수 있다. 체인의 잠재적 단점 중 하나는 디버깅이 어렵다는 것이다. 메서드 호출 중에 생성된 중간 객체는 별도의 변수에 저장되지 않으므로 체인 중에서 발생한 오류의 정확한 위치를 추적하기 어렵다. 체인 디버깅을 위한 옵션은 .pipe() 메서드를 호출해 중간값을 표시하는 것이다. 시리즈에 대한 .pipe() 메서드에서는 시리즈를 입력으로 취하는 함수를 전달해야만 하고 함수의 출력은 무엇이든 가능하다. . (fb_likes.fillna(0) #.astype(int) #.head() ) (fb_likes.fillna(0) .astype(int) #.head() ) fb_likes.fillna(0) .astype(int) .head() def debug_df(df): print(&quot;BEFORE&quot;) print(df) print(&quot;AFTER&quot;) return df (fb_likes.fillna(0) .pipe(debug_df) .astype(int) .head() ) intermediate = None def get_intermediate(df): global intermediate intermediate = df return df res = (fb_likes.fillna(0) .pipe(get_intermediate) .astype(int) .head() ) . 중간값을 저장하는 전역 변수를 생성하고 .pipe() 메서드를 사용할 수 있다. 체인을 괄호로 묶는 것을 선호한다. 체인에 메서드를 추가할 때마다 후행 백슬래시를 계속 추가해야 하는 것은 성가신 일이다. . 열 이름 변경 . movies = pd.read_csv(&#39;../data/movie.csv&#39;) col_map = {&#39;director_name&#39;:&#39;Director Name&#39;, &#39;num_critic_for_reviews&#39;: &#39;Critical Reviews&#39;} movies.rename(columns=col_map).head() . 데이터 프레임의 .rename() 메서드를 사용하면 열 레이블의 이름을 바꿀 수 있다. columns 속성에 대입하면 열 이름이 바뀐다. 그러나 이 대입을 체인시킬 수 없다. . idx_map = {&#39;Avatar&#39;:&#39;Ratava&#39;, &#39;Spectre&#39;: &#39;Ertceps&#39;, &quot;Pirates of the Caribbean: At World&#39;s End&quot;: &#39;POC&#39;} col_map = {&#39;aspect_ratio&#39;: &#39;aspect&#39;, &quot;movie_facebook_likes&quot;: &#39;fblikes&#39;} (movies .set_index(&#39;movie_title&#39;) .rename(index=idx_map, columns=col_map) .head(3) ) movies = pd.read_csv(&#39;../data/movie.csv&#39;, index_col=&#39;movie_title&#39;) ids = movies.index.tolist() columns = movies.columns.tolist() ids[0] = &#39;Ratava&#39; ids[1] = &#39;POC&#39; ids[2] = &#39;Ertceps&#39; columns[1] = &#39;director&#39; columns[-2] = &#39;aspect&#39; columns[-1] = &#39;fblikes&#39; movies.index = ids movies.columns = columns def to_clean(val): return val.strip().lower().replace(&#39; &#39;, &#39;_&#39;) movies.rename(columns=to_clean).head(3) cols = [col.strip().lower().replace(&#39; &#39;, &#39;_&#39;) for col in movies.columns] movies.columns = cols movies.head(3) . 원하는 경우 .rename()를 사용해 인덱스의 이름을 바꿀 수도 있다. 행과 열 레이블의 이름을 바꾸는 방법에는 여러 가지가 있다. 인덱스와 열 속성을 파이썬 리스트에 다시 대입할 수도 있다. 이 경우 리스트에 행과 열 레이블과 동일한 개수의 원소가 있을 때 작동한다. .rename() 메서드에 함수를 전달할 수도 있다. 이 함수는 열 이름을 취한 뒤 새 이름을 반환한다. 리스트 컴프리핸션도 사용할 수 있다. 새로 정리된 목록을 .columns 특성으로 다시 할당하면 된다. . 열의 생성과 삭제 . .assign() 메서드를 사용해 새 열을 만든 다음 .drop() 메서드를 사용해 열을 삭제한다. 새 열을 만드는 한 가지 방법은 인덱스 대입을 실행하는 것이다. 기본적으로 새 열은 마지막에 추가된다. . movies = pd.read_csv(&#39;../data/movie.csv&#39;) movies[&#39;has_seen&#39;] = 0 . 체인을 많이 사용하는 경우 .assign() 메서드를 사용하자. 이 메서드는 새 열이 추가된 새로운 데이터프레임을 반환한다. 이 메서드는 매개변수 이름을 열 이름으로 사용하므로 열 이름은 유효한 매개변수 이름이어야 한다. . idx_map = {&#39;Avatar&#39;:&#39;Ratava&#39;, &#39;Spectre&#39;: &#39;Ertceps&#39;, &quot;Pirates of the Caribbean: At World&#39;s End&quot;: &#39;POC&#39;} col_map = {&#39;aspect_ratio&#39;: &#39;aspect&#39;, &quot;movie_facebook_likes&quot;: &#39;fblikes&#39;} (movies .rename(index=idx_map, columns=col_map) .assign(has_seen=0) ) . 페이스북의 ‘좋아요’ 개수에 대한 데이터를 합산해 total_likes 열에 할당하자. . total = (movies[&#39;actor_1_facebook_likes&#39;] + movies[&#39;actor_2_facebook_likes&#39;] + movies[&#39;actor_3_facebook_likes&#39;] + movies[&#39;director_facebook_likes&#39;]) . 이번엔 체인할 수 있는 메서드를 사용해보자. . cols = [&#39;actor_1_facebook_likes&#39;,&#39;actor_2_facebook_likes&#39;, &#39;actor_3_facebook_likes&#39;,&#39;director_facebook_likes&#39;] sum_col = movies[cols].sum(axis=&#39;columns&#39;) sum_col.head(5) movies.assign(total_likes=sum_col).head(5) . 또 다른 옵션은 .assign() 메서드 호출에서 매개변수 값으로 함수를 전달하는 것이다. 이 함수는 데이터프레임을 입력으로 받고 시리즈를 반환한다. . def sum_likes(df): return df[[c for c in df.columns if &#39;like&#39; in c]].sum(axis=1) movies.assign(total_likes=sum_likes).head(5) . 이 데이터셋에는 결측치가 있다. + 연산자를 사용하면 결측치가 있을 경우 결과는 NaN이 된다. 그러나 .sum() 메서드를 사용하면 NaN을 0으로 반환한다. . (movies .assign(total_likes=sum_col) [&#39;total_likes&#39;] .isna() .sum() ) (movies .assign(total_likes=total) [&#39;total_likes&#39;] .isna() .sum() ) (movies .assign(total_likes=total.fillna(0)) [&#39;total_likes&#39;] .isna() .sum() ) . 데이터셋에는 cast_total_facebook_likes라는 열이 있다. 이 열 중 얼마나 많은 부분이 방금 새로 만든 열인 total_likes에서 왔는지 확인해보자. 우선 데이터 유효성 검사를 수행하자. . def cast_like_gt_actor_director(df): return df[&#39;cast_total_facebook_likes&#39;] &gt;= df[&#39;total_likes&#39;] df2 = (movies .assign(total_likes=total, is_cast_likes_more = cast_like_gt_actor_director) ) df2[&#39;is_cast_likes_more&#39;].all() . .all() 메서드를 사용하면 해당 열의 모든 값이 True인지 확인할 수 있다. 이번엔 total_likes 컬럼을 삭제해보자. . df2 = df2.drop(columns=&#39;total_likes&#39;) . 배우들이 받은 ‘좋아요’만을 가진 새로운 시리즈를 생성하고 cast_total_facebook_likes에 있는 모든 값이 actor_sum보다 크거나 같은지 확인해보자. 그런 다음 movie_title 열을 인덱스로 사용해 시리즈를 생성할 수 있다. 시리즈 생성자에는 값과 인덱스 모두를 전달할 수 있다. . actor_sum = (movies [[c for c in movies.columns if &#39;actor_&#39; in c and &#39;_likes&#39; in c]] .sum(axis=&#39;columns&#39;) ) movies[&#39;cast_total_facebook_likes&#39;] &gt;= actor_sum movies[&#39;cast_total_facebook_likes&#39;].ge(actor_sum) movies[&#39;cast_total_facebook_likes&#39;].ge(actor_sum).all() pct_like = (actor_sum .div(movies[&#39;cast_total_facebook_likes&#39;]) ) pct_like.describe() pd.Series( pct_like.to_numpy(), # or pct_like.values index=movies[&#39;movie_title&#39;].values).head() . 요약해보자. 새 열을 생성할 때 스칼라를 대입하거나 시리즈를 대입할 수 있다. .drop() 메서드는 삭제할 행이나 열 이름을 취한다. 기본 설정은 인덱스 이름을 기준으로 행을 삭제한다. 열을 삭제하려면 axis 매개변수를 1이나 ‘columns’로 설정해야 한다. 축의 기본 설정값은 0이나 ‘index’이다. .insert() 메서드를 사용해 데이터프레임의 특정 위치에 새 열을 삽입할 수 있다. 이 메서드는 새 열의 정수 위치를 첫 번째 인수로, 새 열의 이름을 두 번째 인수로, 값을 세 번째 인수로 취한다. 열 이름의 정수 위치를 찾으려면 .get_loc 인덱스 메서드를 사용해야 한다. 그리고 이 메서드는 데이터프레임 자체를 수정하므로 대입 명령문이 없다. 그리고 None을 반환한다. 이러한 이유로 .assign() 메서드를 선호한다. 각 영화의 수익을 계산하려면 총매출에서 비용을 제외한 후 gross 열 다음에 삽입하면 된다. . profit_index = movies.columns.get_loc(&#39;gross&#39;) + 1 profit_index movies.insert(loc=profit_index, column=&#39;profit&#39;, value=movies[&#39;gross&#39;] - movies[&#39;budget&#39;]) del movies[&#39;director_name&#39;] . 컬럼을 삭제하는 대안은 del문을 사용하는 것이다. 그러나 이 또한 새로운 데이터프레임을 반환하지 않으므로 .drop() 메서드를 선호한다. . 2장 기본 데이터프레임 연산 . 여러 데이터프레임 열 선택 . 원하는 열의 리스트를 인덱스 연산자에 전달한다. . movies = pd.read_csv(&#39;../data/movie.csv&#39;) movie_actor_director = movies[[&#39;actor_1_name&#39;, &#39;actor_2_name&#39;, &#39;actor_3_name&#39;, &#39;director_name&#39;]] movie_actor_director.head() type(movies.loc[:, [&#39;director_name&#39;]]) # DataFrame type(movies.loc[:, &#39;director_name&#39;]) # Series . .loc을 사용해 열 이름으로 꺼낼 수 있다. 콜론을 사용해 전체 행을 선택한다는 것을 명시해야 한다. 인덱스 연산을 사용하면 시리즈나 데이터프레임을 반환할 수 있다. 단일 아이템을 가진 리스트를 전달하면 데이터프레임을 반환받는다. 문자열로 된 열의 이름을 전달하면 시리즈를 반환받는다. . cols = [&#39;actor_1_name&#39;, &#39;actor_2_name&#39;, &#39;actor_3_name&#39;, &#39;director_name&#39;] movie_actor_director = movies[cols] . 인덱스 연산자 내에 긴 리스트를 전달하면 가독성 문제가 발생할 수 있다. 이를 피하고자 필요한 열 이름을 리스트 변수에 먼저 저장할 수 있다. 판다스로 작업할 때 발생하는 가장 일반적인 예외 상황 중 하나는 KeyError다. 이 오류는 주로 열이나 인덱스 이름이 잘못되었을 경우 발생한다. . 메서드를 사용해 열 선택 . .select_dtypes()와 .filter() 메서드를 사용할 수 있다. . def shorten(col): return (col.replace(&#39;facebook_likes&#39;, &#39;fb&#39;) .replace(&#39;_for_reviews&#39;, &#39;&#39;) ) movies = movies.rename(columns=shorten) movies.dtypes.value_counts() movies.select_dtypes(include=&#39;int&#39;).head() movies.select_dtypes(include=&#39;number&#39;).head() movies.select_dtypes(include=[&#39;int&#39;, &#39;object&#39;]).head() movies.select_dtypes(exclude=&#39;float&#39;).head() movies.filter(like=&#39;fb&#39;).head() cols = [&#39;actor_1_name&#39;, &#39;actor_2_name&#39;, &#39;actor_3_name&#39;, &#39;director_name&#39;] movies.filter(items=cols).head() movies.filter(regex=r&#39; d&#39;).head() . .select_dtypes() 메서드를 사용해 특정 데이터 타입을 지닌 열을 선택할 수 있다. 모든 수치 열만 선택하려면 include 매개변수에 number라는 문자열을 전달하면 된다. 리스트로 넘겨서 정수와 문자열로 된 열을 얻을 수 있다. 제외하고 싶을 땐 exclude 매개변수를 이용하자. 열을 선택하는 다른 방법은 .filter() 메서들르 이용하는 것이다. like 매개변수는 열 이름에서 부분 문자열을 찾는다. items 매개변수를 사용하면 열 이름을 리스트로 전달할 수 있다. 이 매개변수는 거의 인덱스 연산을 복제한 것과 같다. 그러나 KeyError가 발생하지 않는다. 그리고 regex 매개변수로 정규표현식을 사용해 열을 검색할 수 있다. items, like, regex 중 하나의 매개변수만 사용할 수 있다. .select_dtypes() 메서드의 혼란스러운 점 중 하나는 문자열과 파이썬 객체를 모두 사용할 수 있다는 유연성이다. 둘 다 알아놓자. . np.number, ‘number’ : 크기와 상관없이 정수와 부동소수를 모두 선택 | np.float64, np.float_, float, ‘float64’, ‘float_’, ‘float’ : 64비트 부동소수점 수만 선택 | np.float16, np.float32, np.float128, ‘float16’, ‘float32’, ‘float128’ : 각각 정확히 16, 32, 128비트 부동소수점 수 선택 | np.floating, ‘floating’ : 크기와 상관없이 부동소수점 수 선택 | np.int0, np.int64, np.int_, int, ‘int0’, ‘int64’, ‘int_’, ‘int’ : 정확히 64비트 정수만 선택 | np.int8, np.int16, np.int32, ‘int8’, ‘int16’, ‘int32’ : 각각 정확히 8, 16, 32비트 정수 선택 | np.integer, ‘integer’ : 크기와 상관없이 모든 정수 | ‘Int64’ : null 값을 허용하는 정수로, 넘파이에는 없음 | np.object, ‘object’, ‘O’ : 모든 object 데이터 형식 | np.datetime64, ‘datetime64’, ‘datetime’ : 모든 datetime은 64비트 | np.timedelta64, ‘timedelta64’, ‘timedelta’ : 모든 timedelta는 64비트 | pd.Categorical, ‘category’ : 판다스에만 존재하고 넘파이에는 없음 | . 열 이름 정렬 . 다음은 열을 정렬하는 지침이다. . 각 열을 범주형이나 연속형으로 분류하라. | 범주형과 연속형 열 내에서 공통된 열을 그룹화하라. | 가장 중요한 열 그룹을 먼저 위치시키고 연속형보다 범주형 열을 먼저 위치시켜라. | . movies = pd.read_csv(&#39;../data/movie.csv&#39;) def shorten(col): return (col.replace(&#39;facebook_likes&#39;, &#39;fb&#39;) .replace(&#39;_for_reviews&#39;, &#39;&#39;) ) movies = movies.rename(columns=shorten) cat_core = [&#39;movie_title&#39;, &#39;title_year&#39;, &#39;content_rating&#39;, &#39;genres&#39;] cat_people = [&#39;director_name&#39;, &#39;actor_1_name&#39;, &#39;actor_2_name&#39;, &#39;actor_3_name&#39;] cat_other = [&#39;color&#39;, &#39;country&#39;, &#39;language&#39;, &#39;plot_keywords&#39;, &#39;movie_imdb_link&#39;] cont_fb = [&#39;director_fb&#39;, &#39;actor_1_fb&#39;, &#39;actor_2_fb&#39;, &#39;actor_3_fb&#39;, &#39;cast_total_fb&#39;, &#39;movie_fb&#39;] cont_finance = [&#39;budget&#39;, &#39;gross&#39;] cont_num_reviews = [&#39;num_voted_users&#39;, &#39;num_user&#39;, &#39;num_critic&#39;] cont_other = [&#39;imdb_score&#39;, &#39;duration&#39;, &#39;aspect_ratio&#39;, &#39;facenumber_in_poster&#39;] new_col_order = cat_core + cat_people + cat_other + cont_fb + cont_finance + cont_num_reviews + cont_other set(movies.columns) == set(new_col_order) movies[new_col_order].head() . 새로운 열 순서를 담은 리스트가 원래 열을 모두 포함하도록 보장해야 한다. 해들리 위컴은 먼저 고정 변수를 배치한 다음 측정 변수를 배치할 것을 제안했다. . 데이터프레임 요약 . 단일 열이나 시리즈 데이터를 대상으로 작동하는 다양한 메서가 있었다. 그중 다수는 단일 스칼라 값을 반환하는 집계 혹은 축약 메서드였다. 데이터프레임에서 이와 동일한 메서드를 호출하면 각 열에 대해 해당 작업을 한꺼번에 수행하고 데이터프레임의 각 열에 대한 결과를 축약한다. . movies = pd.read_csv(&#39;../data/movie.csv&#39;) movies.shape movies.size movies.ndim len(movies) movies.count() movies.min() movies.describe().T movies.describe(percentiles=[.01, .3, .99]).T . .shape 속성은 행과 열 수를 가진 튜플을 반환한다. .size 속성은 데이터프레임의 총 원소 개수를 반환하는데 행과 열 개수의 곱이다. .ndim 속성은 차원수를 반환하는데 모든 데이터프레임은 2이다. .count() 메서드는 각 열에서 결측치가 아닌 데이터 개수를 보여준다. 이는 각 열을 하나의 단일값으로 요약하므로 집계 메서드다. 출력은 열 이름을 인덱스로 갖는 시리즈다. 요약 통계량을 계산하는 메서드들은 수치 열의 열 이름을 인덱스로 하고 각 집계치를 값으로 갖는 시리즈를 반환한다. .describe() 메서드는 기술통계량과 분위수를 동시에 계산한다. 이 메서드는 수치 열의 요약 통계량을 표시한다. .T를 사용해 결과를 전치시키면 화면에 더 많은 정보를 표시할 수 있다. percentiles 매개변수를 사용하면 .describe() 메서드에 정확한 분위수를 지정할 수 있다. 판다스 기본설정에서 숫자 열에서 누락된 값은 건너뛰고 처리한다. . movies.min(skipna=False) . skipna 매개변수를 False로 설정하면 적어도 하나의 결측치가 존재하는 경우 판다스는 모든 집계 메서드에서 NaN을 반환한다. . 데이터프레임 메서드 체인 . 메서드 체인의 가장 핵심은 체인의 각 단계에서 반환되는 정확한 객체를 아는 것이다. 판다스에서는 거의 항상 데이터프레임이나 시리즈 또는 스칼라 값이다. . movies = pd.read_csv(&#39;../data/movie.csv&#39;) def shorten(col): return (col.replace(&#39;facebook_likes&#39;, &#39;fb&#39;) .replace(&#39;_for_reviews&#39;, &#39;&#39;) ) movies = movies.rename(columns=shorten) movies.isnull().head() (movies .isnull() .sum() .head() ) movies.isnull().sum().sum() movies.isnull().any().any() . 전체 결측치의 개수를 스칼라 값으로 확인하고 싶으면 .isnull().sum().sum() 데이터프레임에 결측치가 있는지 확인하려면 .isnull().any().any() object 데이터 형식이며 결측치를 가진 열은 집계 메서드(.min(), .max(), .sum())로부터 아무것도 반환하지 못한다. 따라서 결측치를 채워야 한다. . with pd.option_context(&#39;max_colwidth&#39;, 20): movies.select_dtypes([&#39;object&#39;]).fillna(&#39;&#39;).max() . 데이터프레임 연산 . 판다스는 뱅커 반올림 연산을 한다. 즉 숫자가 양쪽의 한 가운데 있을 경우 가까운 짝수 쪽으로 만들어 버린다. 소수 두 자리수로 반올림할 때 이 시리즈의 UGDS_BLACK 행이 어떻게 되는지 살펴보자. . colleges = pd.read_csv(&#39;../data/college.csv&#39;, index_col=&#39;INSTNM&#39;) college_ugds = colleges.filter(like=&#39;UGDS_&#39;) college_ugds.head() name = &#39;Northwest-Shoals Community College&#39; college_ugds.loc[name] college_ugds.loc[name].round(2) (college_ugds.loc[name] + .0001).round(2) college_ugds + .00501 (college_ugds + .00501) // .01 college_ugds_op_round = (college_ugds + .00501) // .01 / 100 college_ugds_op_round.head() college_ugds_round = (college_ugds + .00001).round(2) college_ugds_round college_ugds_op_round.equals(college_ugds_round) . 판다스가 뱅커 반올림하기 전에 .0001을 더하면 반올림된다. 소수 2번째 자리까지 나타내려고 할 때 수학적으로 .005를 더하면 다음 단계의 정수 나눗셈이 가장 가까운 정수 백분율로 반올림되게 하는 데 충분하다. 그러나 부동소수점의 부정확성으로 인해 문제가 발생한다. 부동소수점 표현의 첫 번째 4자리 숫자가 실제 값과 동일하게 각 숫자에 .00001이 더하면 된다. 해당 데이터셋에서 모든 점의 최대 정밀도가 소수점 이하 네 자리이기 때문이다. 뱅커 반올림은 숫자가 지속적으로 더 높은 쪽으로 치우치는 것을 막아준다. .equals() 메서드는 두 데이터프레임 사이의 모든 요소와 인덱스가 정확히 동일한지 여부를 판별하고 불리언을 반환한다. 결론은 소수점을 반올림 하고 싶으면 최대 정밀도보다 하나 더 큰 정밀도로 소수를 더해줘서 round 메서드를 사용하면 된다. . college2 = (college_ugds .add(.00501) .floordiv(.01) .div(100) ) college2.equals(college_ugds_op_round) . 시리즈와 마찬가지로 데이터프레임에도 연산자와 동등한 메서드가 있다. . 결측치 비교 . 판다스는 np.nan 객체를 사용해 결측치를 나타낸다. 이 객체는 자신과 같지 않다. . np.nan == np.nan # False . 시리즈와 데이터프레임은 요소별 비교를 위해 ‘같음’ 연산자 ==를 사용한다. 결과는 동일한 차원의 객체다. . college = pd.read_csv(&#39;../data/college.csv&#39;, index_col=&#39;INSTNM&#39;) college_ugds = college.filter(like=&#39;UGDS_&#39;) college_ugds == .0019 college_self_compare = college_ugds == college_ugds college_self_compare.head() college_self_compare.all() (college_ugds == np.nan).sum() college_ugds.isnull().sum() college_ugds.equals(college_ugds) . 등호 연산자는 결측치가 있는 데이터프레임과 비교할 때 문제가 된다. 자기 자신을 등호를 사용해 연산하면 .all() 메서드를 사용한 결과에 모두 True가 있을 것 같지만 결과는 전혀 다르다. 이 문제는 결측치가 서로 같은 것으로 여겨지지 않기 때문이다. 등호 연산자를 사용해 결측치를 ‘같음’ 연산자를 사용해 세고 불리언 열을 합산하려고 하면 각각에 대해 0을 얻게 된다. 이 또한 당연한 결과다. 따라서 결측치 수를 얻는 데 등호 연산자가 아닌 .isna() 메서드를 사용하라. 두 개의 전체 데이터프레임을 서로 비교하는 올바른 방법은 등호 연산자가 아니라 .equals() 메서드를 사용하는 것이다. 이 메서드는 같은 위치에 있는 NaN을 동일하게 취급한다. . college_ugds.eq(.0019) # same as college_ugds == .0019 from pandas.testing import assert_frame_equal assert_frame_equal(college_ugds, college_ugds) is None . .eq() 메서드는 == 연산자와 마찬가지로 요소별 비교를 수행한다. .eq() 메서드는 .equals() 메서드와 전혀 다르다. pandas.testing 서브패키지 안에는 개발자들이 단위 테스트를 생성할 때 사용해야 하는 함수가 있다. asert_frame_equal 함수는 두 개의 데이터프레임이 같이 않으면 AssertionError를 발생시킨다. 만약 같은 경우 None을 반환한다. . 데이터프레임 연산 방향 전환 . 많은 데이터프레임 메서드에는 axis 매개변수가 있다. 이 매개변수는 연산이 진행되는 방향을 제어한다. axis 매개변수는 ‘index’(또는 0) 또는 ‘columns’(또는 1)이다. 거의 모든 데이터프레임 메서드는 기본적으로 axis 매개변수를 0으로 설정하며 인덱스를 따르는 작업에 적용된다. . college = pd.read_csv(&#39;../data/college.csv&#39;, index_col=&#39;INSTNM&#39;) college_ugds = college.filter(like=&#39;UGDS_&#39;) college_ugds.head() college_ugds.count() college_ugds.count(axis=&#39;columns&#39;).head() college_ugds.sum(axis=&#39;columns&#39;).head() college_ugds.median(axis=&#39;index&#39;) college_ugds_cumsum = college_ugds.cumsum(axis=1) college_ugds_cumsum.head() . UGDS로 시작하는 열은 특정 인종의 학부생 비율을 나타낸다. .filter() 메서드를 사용해 이 열들을 선택한다. .count() 메서드는 결측치가 아닌 개수를 반환한다. axis 매개변수를 ‘columns’로 변경하면 연산의 방향이 변경된다. 결측치를 계산하는 대신 각 행의 모든 값을 합할 수 있다. 이 때 각 백분율 행은 합산이 1이 되어야 한다. .sum() 메서드를 사용해 확인할 수 있다. 각 열의 분포를 알아보려면 .median() 메서드를 사용할 수 있다. .cumsum() 메서드는 누적합을 보여준다. . 대학 인종 다양성 지수 결정 . college = pd.read_csv(&#39;../data/college.csv&#39;, index_col=&#39;INSTNM&#39;) college_ugds = college.filter(like=&#39;UGDS_&#39;) (college_ugds.isnull() .sum(axis=&#39;columns&#39;) .sort_values(ascending=False) .head() ) college_ugds = college_ugds.dropna(how=&#39;all&#39;) college_ugds.isnull().sum() college_ugds.ge(.15) diversity_metric = college_ugds.ge(.15).sum(axis=&#39;columns&#39;) diversity_metric.head() diversity_metric.value_counts() diversity_metric.sort_values(ascending=False).head() college_ugds.loc[[&#39;Regency Beauty Institute-Austin&#39;, &#39;Central Texas Beauty College-Temple&#39;]] us_news_top = [&#39;Rutgers University-Newark&#39;, &#39;Andrews University&#39;, &#39;Stanford University&#39;, &#39;University of Houston&#39;, &#39;University of Nevada-Las Vegas&#39;] diversity_metric.loc[us_news_top] (college_ugds .max(axis=1) .sort_values(ascending=False) .head(10) ) (college_ugds &gt; .01).all(axis=1).any() . 많은 대학에서 인종 열에 결측치가 있다. 모든 열에 대해 결측치 개수를 파악하고 결과 시리즈를 내림차순으로 정렬한다. .dropna() 메서드를 사용해 9개 인종 모두에 대한 값이 누락된 전체 행을 제거한다. ‘크거나 같다’의 데이터프레임 메서드인 .ge()를 사용해 각 셀에 대한 불리언 값을 가진 데이터프레임을 구한다. .sum() 메서드를 사용해 각 대학의 True 값을 알아본다. 그리고 .value_counts() 메서드를 통해 분포를 파악한다. 두 학교가 5가지 인종 범주에 대해 15% 이상의 학생을 갖고 있다. 해당 학교를 .loc 인덱스로 선택해보자. 범주를 알 수 없는 둘 이상의 인종 열이 집계되었다. .dropna() 메서드에는 how라는 매개변수가 있으며 기본 설정 값은 문자열 ‘any’이지만 ‘all’로 변경할 수 있다. ‘any’로 설정하면 하나 이상의 결측치가 포함된 행이 삭제된다. ‘all’로 설정하면 모든 값이 누락된 행만 삭제된다. 가장 다양화되지 않은 학교도 착을 수 있다. 그리고 9개 범주 모두가 1%를 넘는 학교도 알아볼 수 있다. .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/database/dbms/mysql/datatype/2021/11/05/post020.html",
            "relUrl": "/markdown/database/dbms/mysql/datatype/2021/11/05/post020.html",
            "date": " • Nov 5, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "MySQL Data Types",
            "content": "Chapter 11 Data Types . MySQL은 숫자 유형, 날짜 및 시간 유형, 문자열(문자 및 바이트) 유형, 공간 유형 및 JSON 데이터 유형과 같은 여러 범주의 SQL 데이터 유형을 지원합니다. 이 장에서는 각 범주의 유형 속성에 대한 개요 및 자세한 설명과 데이터 유형 저장 요구 사항에 대한 요약을 제공합니다. 초기 개요는 의도적으로 간략합니다. 값을 지정할 수 있는 허용되는 형식과 같은 특정 데이터 유형에 대한 추가 정보는 보다 자세한 설명을 참조하십시오. . 데이터 유형 설명은 다음 규칙을 사용합니다. . 정수 유형의 경우 M은 최대 표시 너비를 나타냅니다. 부동 소수점 및 고정 소수점 유형의 경우 M은 저장할 수 있는 총 자릿수(정밀도)입니다. 문자열 유형의 경우 M은 최대 길이입니다. M의 최대 허용 값은 데이터 유형에 따라 다릅니다. | D는 부동 소수점 및 고정 소수점 유형에 적용되며 소수점 이하 자릿수(스케일)를 나타냅니다. 가능한 최대 값은 30이지만 M-2보다 크지 않아야 합니다. | fsp는 TIME, DATETIME 및 TIMESTAMP 유형에 적용되며 소수 초 정밀도를 나타냅니다. 즉, 초의 소수 부분에 대한 소수점 이하 자릿수입니다. fsp 값이 주어진 경우 0에서 6 사이여야 합니다. 값이 0이면 소수 부분이 없음을 나타냅니다. 생략하면 기본 정밀도는 0입니다. (이전 MySQL 버전과의 호환성을 위해 표준 SQL 기본값인 6과 다릅니다.) | 대괄호([ 및 ])는 유형 정의의 선택적 부분을 나타냅니다. | . 11.1 숫자 데이터 유형 . 11.1.1 숫자 데이터 유형 구문 11.1.2 정수 유형(정확한 값) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT 11.1.3 고정 소수점 유형(정확한 값) - DECIMAL, NUMERIC 11.1.4 부동 소수점 유형(근사값) - FLOAT, DOUBLE 11.1.5 비트 값 유형 - BIT 11.1.6 숫자 유형 속성 11.1.7 범위 초과 및 오버플로 처리 . MySQL은 모든 표준 SQL 숫자 데이터 유형을 지원합니다. 이러한 유형에는 정확한 숫자 데이터 유형(INTEGER, SMALLINT, DECIMAL 및 NUMERIC)과 대략적인 숫자 데이터 유형(FLOAT, REAL 및 DOUBLE PRECISION)이 포함됩니다. 키워드 INT는 INTEGER의 동의어이고 키워드 DEC 및 FIXED는 DECIMAL의 동의어입니다. MySQL은 DOUBLE을 DOUBLE PRECISION(비표준 확장)의 동의어로 취급합니다. MySQL은 또한 REAL_AS_FLOAT SQL 모드가 활성화되지 않는 한 REAL을 DOUBLE PRECISION(비표준 변형)의 동의어로 취급합니다. . BIT 데이터 유형은 비트 값을 저장하며 MyISAM, MEMORY, InnoDB 및 NDB 테이블에 대해 지원됩니다. . MySQL이 표현식 평가 중 열에 대한 범위를 벗어난 값의 할당과 오버플로를 처리하는 방법에 대한 정보는 11.1.7절 “범위를 벗어나고 오버플로 처리”를 참조하십시오. . 숫자 데이터 유형의 저장 요구 사항에 대한 정보는 11.7절 “데이터 유형 저장 요구 사항”에서 참조하십시오. . 숫자 값에 대해 작동하는 함수에 대한 설명은 12.6절 “숫자 함수 및 연산자”를 참조하십시오. 숫자 피연산자에 대한 계산 결과에 사용되는 데이터 유형은 피연산자의 유형과 피연산자에 대해 수행되는 연산에 따라 다릅니다. 자세한 내용은 12.6.1절 “산술 연산자”에서 참조하십시오. . 11.1.1 숫자 데이터 유형 구문 . 정수 데이터 유형의 경우 M은 최대 표시 너비를 나타냅니다. 최대 표시 너비는 255입니다. 표시 너비는 11.1.6절 “숫자 유형 속성”에 설명된 대로 유형이 저장할 수 있는 값의 범위와 관련이 없습니다. . 부동 소수점 및 고정 소수점 데이터 유형의 경우 M은 저장할 수 있는 총 자릿수입니다. . MySQL 8.0.17부터 display width 속성은 정수 데이터 유형에 대해 더 이상 사용되지 않습니다. 향후 MySQL 버전에서는 지원이 제거될 것으로 예상해야 합니다. . 숫자 열에 대해 ZEROFILL을 지정하면 MySQL은 자동으로 해당 열에 UNSIGNED 속성을 추가합니다. . MySQL 8.0.17부터 ZEROFILL 속성은 숫자 데이터 유형에 대해 더 이상 사용되지 않습니다. 향후 MySQL 버전에서는 지원이 제거될 것으로 예상해야 합니다. 이 속성의 효과를 생성하는 대체 수단을 사용하는 것을 고려하십시오. 예를 들어, 응용 프로그램은 LPAD() 함수를 사용하여 원하는 너비까지 숫자를 0으로 채우거나 형식이 지정된 숫자를 CHAR 열에 저장할 수 있습니다. . UNSIGNED 속성을 허용하는 숫자 데이터 유형은 SIGNED도 허용합니다. 그러나 이러한 데이터 유형은 기본적으로 signed 되므로 SIGNED 속성은 영향을 미치지 않습니다. . MySQL 8.0.17부터 UNSIGNED 속성은 FLOAT, DOUBLE 및 DECIMAL 유형의 열(및 모든 동의어)에 대해 더 이상 사용되지 않습니다. 향후 MySQL 버전에서는 지원이 제거될 것으로 예상해야 합니다. 이러한 열 대신에 간단한 CHECK 제약 조건을 사용하는 것이 좋습니다. . SERIAL은 BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE의 별칭입니다. . 정수 열 정의에서 SERIAL DEFAULT VALUE는 NOT NULL AUTO_INCREMENT UNIQUE에 대한 별칭입니다. . BIT[(M)] 비트 값 유형입니다. M은 1에서 64 사이의 값당 비트 수를 나타냅니다. M이 생략된 경우 기본값은 1입니다. | TINYINT[(M)] [UNSIGNED] [ZEROFILL] 매우 작은 정수입니다. 부호 있는 범위는 -128 ~ 127입니다. 부호 없는 범위는 0 ~ 255입니다. | BOOL, BOOLEAN 이러한 유형은 TINYINT(1)의 동의어입니다. 값이 0이면 false로 간주됩니다. 0이 아닌 값은 true로 간주됩니다. . | SMALLINT[(M)] [서명되지 않음] [ZEROFILL] 작은 정수. 부호 있는 범위는 -32768 ~ 32767입니다. 부호 없는 범위는 0 ~ 65535입니다. . | MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL] 중간 크기의 정수입니다. 부호 있는 범위는 -8388608 ~ 8388607입니다. 부호 없는 범위는 0 ~ 16777215입니다. . | INT[(M)] [UNSIGNED] [ZEROFILL] 일반 크기의 정수입니다. 부호 있는 범위는 -2147483648 ~ 2147483647입니다. 부호 없는 범위는 0 ~ 4294967295입니다. . | INTEGER[(M)] [UNSIGNED] [ZEROFILL] 이 유형은 INT의 동의어입니다. . | BIGINT[(M)] [UNSIGNED] [ZEROFILL] 큰 정수입니다. 부호 있는 범위는 -9223372036854775808 ~ 9223372036854775807입니다. 부호 없는 범위는 0 ~ 18446744073709551615입니다. . SERIAL은 BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE의 별칭입니다. . BIGINT 열과 관련하여 알아야 할 몇 가지 사항: . 모든 산술은 부호 있는 BIGINT 또는 DOUBLE 값을 사용하여 수행되므로 비트 함수를 제외하고 9223372036854775807(63비트)보다 큰 부호 없는 큰 정수를 사용해서는 안 됩니다! 그렇게 하면 BIGINT 값을 DOUBLE로 변환할 때 반올림 오류로 인해 결과의 마지막 숫자 중 일부가 틀릴 수 있습니다. . | MySQL은 다음과 같은 경우 BIGINT를 처리할 수 있습니다. 정수를 사용하여 BIGINT 열에 큰 부호 없는 값을 저장할 때. | MIN(col_name) 또는 MAX(col_name)에서 col_name은 BIGINT 열을 나타날 때. | 두 피연산자가 모두 정수인 연산자(+, -, * 등)를 사용할 때. | . | 문자열을 사용하여 저장하여 항상 정확한 정수 값을 BIGINT 열에 저장할 수 있습니다. 이 경우 MySQL은 중간 배정밀도 표현을 포함하지 않는 문자열에서 숫자로의 변환을 수행합니다. | -, + 및 * 연산자는 두 피연산자가 모두 정수 값인 경우 BIGINT 산술을 사용합니다. 즉, 두 개의 큰 정수(또는 정수를 반환하는 함수의 결과)를 곱하면 결과가 9223372036854775807보다 크면 예기치 않은 결과가 발생할 수 있습니다. | . | DECIMAL[(M[,D])] [UNSIGNED] [ZEROFILL] 압축된 “정확한” 고정 소수점 수입니다. M은 총 자릿수(정밀도)이고 D는 소수점 이하 자릿수(스케일)입니다. 소수점과 (음수의 경우) - 기호는 M에서 계산되지 않습니다. D가 0이면 값에는 소수점이나 소수 부분이 없습니다. DECIMAL의 최대 자릿수(M)는 65입니다. 지원되는 최대 소수 자릿수(D)는 30입니다. D를 생략하면 기본값은 0입니다. M을 생략하면 기본값은 10입니다. (DECIMAL 리터럴의 텍스트 길이 제한, 섹션 12.25.3, “표현식 처리” 참조) . UNSIGNED는 지정된 경우 음수 값을 허용하지 않습니다. MySQL 8.0.17부터 UNSIGNED 속성은 DECIMAL 유형의 열(및 모든 동의어)에 대해 더 이상 사용되지 않습니다. 향후 MySQL 버전에서는 지원이 제거될 것으로 예상해야 합니다. 이러한 열 대신에 간단한 CHECK 제약 조건을 사용하는 것이 좋습니다. . DECIMAL 열이 있는 모든 기본 계산(+, -, *, /)은 65자리의 정밀도로 수행됩니다. . | DEC[(M[,D])] [UNSIGNED] [ZEROFILL], NUMERIC[(M[,D])] [UNSIGNED] [ZEROFILL], FIXED[(M[,D])] [UNSIGNED] [ZEROFILL] 이러한 유형은 DECIMAL의 동의어입니다. FIXED 동의어는 다른 데이터베이스 시스템과의 호환성을 위해 사용할 수 있습니다. . | FLOAT[(M,D)] [UNSIGNED] [ZEROFILL] 작은(단정밀도) 부동 소수점 숫자입니다. 허용되는 값은 -3.402823466E+38 ~ -1.175494351E-38, 0 및 1.175494351E-38 ~ 3.402823466E+38입니다. IEEE 표준을 기반으로 하는 이론적인 한계입니다. 실제 범위는 하드웨어 또는 운영 체제에 따라 약간 더 작을 수 있습니다. M은 총 자릿수이고 D는 소수점 이하 자릿수입니다. M과 D가 생략되면 값은 하드웨어에서 허용하는 한계까지 저장됩니다. 단정밀도 부동 소수점 숫자는 소수점 이하 약 7자리까지 정확합니다. FLOAT(M,D)는 비표준 MySQL 확장입니다. MySQL 8.0.17부터 이 구문은 더 이상 사용되지 않으며 향후 MySQL 버전에서는 이 구문에 대한 지원이 제거될 것으로 예상해야 합니다. UNSIGNED는 지정된 경우 음수 값을 허용하지 않습니다. MySQL 8.0.17부터 UNSIGNED 속성은 FLOAT 유형의 열(및 모든 동의어)에 대해 더 이상 사용되지 않으며 향후 MySQL 버전에서 제거될 것으로 예상해야 합니다. 이러한 열 대신에 간단한 CHECK 제약 조건을 사용하는 것이 좋습니다. FLOAT를 사용하면 MySQL의 모든 계산이 배정밀도로 수행되기 때문에 예상치 못한 문제가 발생할 수 있습니다. B.3.4.7절. “일치하는 행이 없는 문제 해결”을 참조하십시오. . | FLOAT(p) [UNSIGNED] [ZEROFILL] 부동 소수점 숫자입니다. p는 비트 단위의 정밀도를 나타내지만 MySQL은 결과 데이터 유형에 대해 FLOAT 또는 DOUBLE을 사용할지 여부를 결정하기 위해서만 이 값을 사용합니다. p가 0에서 24 사이이면 데이터 유형은 M 또는 D 값이 없는 FLOAT가 됩니다. p가 25~53이면 데이터 유형은 M 또는 D 값이 없는 DOUBLE이 됩니다. 결과 열의 범위는 이 섹션의 앞부분에서 설명한 단정밀도 FLOAT 또는 배정밀도 DOUBLE 데이터 유형과 동일합니다. . UNSIGNED는 지정된 경우 음수 값을 허용하지 않습니다. MySQL 8.0.17부터 UNSIGNED 속성은 FLOAT 유형의 열(및 모든 동의어)에 대해 더 이상 사용되지 않으며 향후 MySQL 버전에서 제거될 것으로 예상해야 합니다. 이러한 열 대신에 간단한 CHECK 제약 조건을 사용하는 것이 좋습니다. . FLOAT(p) 구문은 ODBC 호환성을 위해 제공됩니다. . | DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL] 일반 크기(배정밀도) 부동 소수점 숫자입니다. 허용되는 값은 -1.7976931348623157E+308 ~ -2.2250738585072014E-308, 0 및 2.2250738585072014E-308 ~ 1.7976931348입니다. IEEE 표준을 기반으로 하는 이론적인 한계입니다. 실제 범위는 하드웨어 또는 운영 체제에 따라 약간 더 작을 수 있습니다. . M은 총 자릿수이고 D는 소수점 이하 자릿수입니다. M과 D가 생략되면 값은 하드웨어에서 허용하는 한계까지 저장됩니다. 배정밀도 부동 소수점 숫자는 대략 소수점 이하 15자리까지 정확합니다. . DOUBLE(M,D)는 비표준 MySQL 확장입니다. MySQL 8.0.17부터 이 구문은 더 이상 사용되지 않으며 향후 MySQL 버전에서는 이 구문에 대한 지원이 제거될 것으로 예상해야 합니다. . UNSIGNED는 지정된 경우 음수 값을 허용하지 않습니다. MySQL 8.0.17부터 UNSIGNED 속성은 DOUBLE 유형의 열(및 모든 동의어)에 대해 더 이상 사용되지 않으며 향후 MySQL 버전에서 지원이 제거될 것으로 예상해야 합니다. 이러한 열 대신에 간단한 CHECK 제약 조건을 사용하는 것이 좋습니다. . | DOUBLE PRECISION[(M,D)] [UNSIGNED] [ZEROFILL], REAL[(M,D)] [UNSIGNED] [ZEROFILL] 이러한 유형은 DOUBLE의 동의어입니다. 예외: REAL_AS_FLOAT SQL 모드가 활성화된 경우 REAL은 DOUBLE이 아닌 FLOAT의 동의어입니다. | . 11.1.2 정수 유형(정확한 값) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT . MySQL은 SQL 표준 정수 유형 INTEGER(또는 INT) 및 SMALLINT를 지원합니다. 표준의 확장으로 MySQL은 정수 유형 TINYINT, MEDIUMINT 및 BIGINT도 지원합니다. 다음 표는 각 정수 유형에 필요한 저장 공간과 범위를 보여줍니다. . Table 11.1 Required Storage and Range for Integer Types Supported by MySQL . Type Storage (Bytes) Minimum Value Signed Minimum Value Unsigned Maximum Value Signed Maximum Value Unsigned . TINYINT | 1 | -128 | 0 | 127 | 255 | . SMALLINT | 2 | -32768 | 0 | 32767 | 65535 | . MEDIUMINT | 3 | -8388608 | 0 | 8388607 | 16777215 | . INT | 4 | -2147483648 | 0 | 2147483647 | 4294967295 | . BIGINT | 8 | -2^63 | 0 | 2^63-1 | 2^64-1 | . 11.1.3 고정 소수점 유형(정확한 값) - DECIMAL, NUMERIC . DECIMAL 및 NUMERIC 유형은 정확한 숫자 데이터 값을 저장합니다. 이러한 유형은 예를 들어 화폐 데이터와 같이 정확한 정밀도를 유지하는 것이 중요할 때 사용됩니다. MySQL에서 NUMERIC은 DECIMAL로 구현되어 있으므로 DECIMAL에 대한 다음 설명은 NUMERIC에도 동일하게 적용됩니다. . MySQL은 DECIMAL 값을 바이너리 형식으로 저장합니다. 12.25절. “정밀도 연산”을 참조하십시오. . DECIMAL 열 선언에서 정밀도와 스케일은 지정될 수 있으며 일반적으로 지정됩니다. 예를 들어: . salary DECIMAL(5,2) . 이 예에서 5는 정밀도이고 2는 스케일입니다. 정밀도는 값에 대해 저장된 유효 자릿수를 나타내고 스케일은 소수점 다음에 저장할 수 있는 자릿수를 나타냅니다. . 표준 SQL에서는 DECIMAL(5,2)이 5자리와 2자리 소수로 모든 값을 저장할 수 있어야 하므로 급여 열에 저장할 수 있는 값의 범위는 -999.99에서 999.99입니다. . 표준 SQL에서 DECIMAL(M) 구문은 DECIMAL(M,0)과 동일합니다. 유사하게, 구문 DECIMAL은 DECIMAL(M,0)과 동일하며, 여기서 M의 값을 결정하도록 구현이 허용됩니다. MySQL은 DECIMAL 구문의 이러한 변형 형태를 모두 지원합니다. M의 기본값은 10입니다. . 스케일이 0이면 DECIMAL 값에는 소수점이나 소수 부분이 포함되지 않습니다. . DECIMAL의 최대 자릿수는 65이지만 지정된 DECIMAL 열의 실제 범위는 지정된 열의 정밀도 또는 소수 자릿수로 제한될 수 있습니다. 이러한 열에 지정된 스케일에서 허용하는 것보다 더 많은 소수점 이하 자릿수가 있는 값이 지정되면 값이 해당 스케일로 변환됩니다. (정확한 동작은 운영 체제에 따라 다르지만 일반적으로 효과는 허용되는 자릿수로 잘립니다.) . 11.1.4 부동 소수점 유형(근사값) - FLOAT, DOUBLE . FLOAT 및 DOUBLE 유형은 대략적인 숫자 데이터 값을 나타냅니다. MySQL은 단정밀도 값에 4바이트를 사용하고 배정밀도 값에 8바이트를 사용합니다. . FLOAT의 경우, SQL 표준은 괄호 안에 키워드 FLOAT 다음에 오는 비트 단위의 정밀도(지수 범위가 아님)의 선택적 사양을 허용합니다. ; 즉, FLOAT(p)입니다. MySQL은 이 선택적 정밀도 사양도 지원하지만 FLOAT(p)의 정밀도 값은 저장소 크기를 결정하는 데만 사용됩니다. 0에서 23 사이의 정밀도는 4바이트 단정밀도 FLOAT 열을 생성합니다. 24에서 53 사이의 정밀도는 8바이트 배정밀도 DOUBLE 열을 생성합니다. . MySQL은 FLOAT(M,D) 또는 REAL(M,D) 또는 DOUBLE PRECISION(M,D)과 같은 비표준 구문을 허용합니다. 여기서 (M,D)는 총 M자리까지 저장할 수 있으며 그 중 D자리는 소수점 이하일 수 있음을 의미합니다. 예를 들어, FLOAT(7,4)로 정의된 열은 -999.9999로 표시됩니다. MySQL은 값을 저장할 때 반올림을 수행하므로 FLOAT(7,4) 열에 999.00009를 삽입하면 대략적인 결과는 999.0001이 됩니다. . MySQL 8.0.17부터 비표준 FLOAT(M,D) 및 DOUBLE(M,D) 구문은 더 이상 사용되지 않으며 향후 MySQL 버전에서 이에 대한 지원이 제거될 것으로 예상해야 합니다. . 부동 소수점 값은 근사치이며 정확한 값으로 저장되지 않기 때문에 비교 시 부동 소수점 값을 정확한 값으로 처리하려고 하면 문제가 발생할 수 있습니다. 또한 플랫폼 또는 구현 종속성의 영향을 받습니다. 자세한 내용은 B.3.4.8절. “부동 소수점 값 문제”에서 참조하십시오. . 최대 이식성을 위해 대략적인 숫자 데이터 값을 저장해야 하는 코드는 정밀도나 자릿수를 지정하지 않고 FLOAT 또는 DOUBLE PRECISION을 사용해야 합니다. . 11.1.5 비트 값 유형 - BIT . BIT 데이터 유형은 비트 값을 저장하는 데 사용됩니다. BIT(M) 유형은 M비트 값을 저장할 수 있습니다. M의 범위는 1에서 64까지입니다. . 비트 값을 지정하려면 b’value’ 표기법을 사용할 수 있습니다. 값은 0과 1을 사용하여 작성된 이진 값입니다. 예를 들어 b’111’과 b’10000000’은 각각 7과 128을 나타냅니다. 9.1.5절. “비트 값 리터럴”을 참조하십시오. . M 비트보다 작은 BIT(M) 열에 값을 할당하면 값이 왼쪽에 0으로 채워집니다. 예를 들어, BIT(6) 열에 b’101’ 값을 할당하는 것은 사실상 b’000101’을 할당하는 것과 같습니다. . NDB 클러스터. 주어진 NDB 테이블에 사용된 모든 BIT 열의 최대 결합 크기는 4096비트를 초과할 수 없습니다. . 11.1.6 숫자 유형 속성 . MySQL은 유형에 대한 기본 키워드 다음에 오는 괄호 안에 정수 데이터 유형의 표시 너비를 선택적으로 지정하기 위한 확장을 지원합니다. 예를 들어, INT(4)는 표시 너비가 4자리인 INT를 지정합니다. 이 선택적 표시 너비는 공백으로 왼쪽을 채워 열에 지정된 너비보다 작은 너비를 갖는 정수 값을 표시하기 위해 애플리케이션에서 사용할 수 있습니다. (즉, 이 너비는 결과 집합과 함께 반환된 메타데이터에 존재합니다. 사용 여부는 응용 프로그램에 달려 있습니다.) . 표시 너비는 열에 저장할 수 있는 값의 범위를 제한하지 않습니다. 또한 열 표시 너비보다 넓은 값이 올바르게 표시되는 것을 방지하지도 않습니다. 예를 들어, SMALLINT(3)으로 지정된 열의 일반적인 SMALLINT 범위는 -32768 ~ 32767이며 세 자리에서 허용하는 범위를 벗어난 값은 세 자리 이상을 사용하여 전체가 표시됩니다. . 선택적(비표준) ZEROFILL 속성과 함께 사용하면 공백의 기본 패딩이 0으로 바뀝니다. 예를 들어 INT(4) ZEROFILL로 선언된 열의 경우 값 5는 0005로 검색됩니다. . NOTE ZEROFILL 속성은 표현식 또는 UNION 쿼리와 관련된 열에 대해 무시됩니다. ZEROFILL 속성이 있는 정수 열에 표시 너비보다 큰 값을 저장하면 MySQL이 일부 복잡한 조인에 대한 임시 테이블을 생성할 때 문제가 발생할 수 있습니다. 이러한 경우 MySQL은 데이터 값이 열 표시 너비에 맞는다고 가정합니다. . MySQL 8.0.17부터 ZEROFILL 속성은 정수 데이터 유형에 대한 표시 너비 속성과 마찬가지로 숫자 데이터 유형에 대해 더 이상 사용되지 않습니다. 향후 MySQL 버전에서는 ZEROFILL 지원 및 정수 데이터 유형에 대한 표시 너비가 제거될 것으로 예상해야 합니다. 이러한 속성의 효과를 생성하는 대체 수단을 사용하는 것을 고려하십시오. 예를 들어, 응용 프로그램은 LPAD() 함수를 사용하여 원하는 너비까지 숫자를 0으로 채우거나 형식이 지정된 숫자를 CHAR 열에 저장할 수 있습니다. . 모든 정수 유형은 선택적(비표준) UNSIGNED 속성을 가질 수 있습니다. 열에 음수가 아닌 숫자만 허용하거나 열에 더 큰 상위 숫자 범위가 필요한 경우 부호 없는 유형을 사용할 수 있습니다. 예를 들어, INT 열이 UNSIGNED이면 열 범위의 크기는 동일하지만 끝점은 -2147483648 및 2147483647에서 0 및 4294967295로 위로 이동합니다. . 부동 소수점 및 고정 소수점 유형도 UNSIGNED일 수 있습니다. 정수 유형과 마찬가지로 이 속성은 음수 값이 열에 저장되는 것을 방지합니다. 정수 유형과 달리 열 값의 상위 범위는 동일하게 유지됩니다. MySQL 8.0.17부터 UNSIGNED 속성은 FLOAT, DOUBLE 및 DECIMAL(및 모든 동의어) 유형의 열에 대해 더 이상 사용되지 않으며 향후 MySQL 버전에서 지원이 제거될 것으로 예상해야 합니다. 이러한 열 대신에 간단한 CHECK 제약 조건을 사용하는 것이 좋습니다. . 숫자 열에 ZEROFILL을 지정하면 MySQL은 자동으로 UNSIGNED 속성을 추가합니다. . 정수 또는 부동 소수점 데이터 유형은 AUTO_INCREMENT 속성을 가질 수 있습니다. 인덱싱된 AUTO_INCREMENT 열에 NULL 값을 삽입하면 열이 다음 시퀀스 값으로 설정됩니다. 일반적으로 값은 현재 테이블에 있는 열의 가장 큰 값인 값+1입니다. (AUTO_INCREMENT 시퀀스는 1로 시작합니다.) . NO_AUTO_VALUE_ON_ZERO SQL 모드가 활성화되지 않는 한 0을 AUTO_INCREMENT 열에 저장하는 것은 NULL을 저장하는 것과 같은 효과를 가집니다. . AUTO_INCREMENT 값을 생성하기 위해 NULL을 삽입하려면 열이 NOT NULL로 선언되어야 합니다. 열이 NULL로 선언된 경우 NULL을 삽입하면 NULL이 저장됩니다. 다른 값을 AUTO_INCREMENT 열에 삽입하면 해당 열이 해당 값으로 설정되고 시퀀스가 ​​재설정되어 다음 자동 생성 값이 삽입된 값에서 순차적으로 따라옵니다. . AUTO_INCREMENT 열에 대한 음수 값은 지원되지 않습니다. . CHECK 제약 조건은 AUTO_INCREMENT 속성이 있는 열을 참조할 수 없으며 CHECK 제약 조건에서 사용되는 기존 열에 AUTO_INCREMENT 속성을 추가할 수도 없습니다. . MySQL 8.0.17부터 AUTO_INCREMENT 지원은 FLOAT 및 DOUBLE 열에 대해 더 이상 사용되지 않습니다. MySQL의 향후 버전에서 제거될 것으로 예상해야 합니다. 이러한 열에서 AUTO_INCREMENT 속성을 제거하거나 정수 유형으로 변환하는 것을 고려하십시오. . 11.1.7 범위 초과 및 오버플로 처리 . MySQL이 열 데이터 유형의 허용 범위를 벗어난 숫자 열에 값을 저장할 때 결과는 당시에 유효한 SQL 모드에 따라 다릅니다. . 엄격한 SQL 모드가 활성화되면 MySQL은 SQL 표준에 따라 범위를 벗어난 값을 오류와 함께 거부하고 삽입이 실패합니다. | 제한 모드가 활성화되지 않은 경우 MySQL은 값을 열 데이터 유형 범위의 적절한 끝점으로 자르고 대신 결과 값을 저장합니다. 범위를 벗어난 값이 정수 열에 할당되면 MySQL은 열 데이터 유형 범위의 해당 끝점을 나타내는 값을 저장합니다. 부동 소수점 또는 고정 소수점 열에 지정된(또는 기본) 정밀도 및 스케일이 암시하는 범위를 초과하는 값이 할당되면 MySQL은 해당 범위의 해당 끝점을 나타내는 값을 저장합니다. | . 테이블 t1에 다음 정의가 있다고 가정합니다. . CREATE TABLE t1 (i1 TINYINT, i2 TINYINT UNSIGNED); . 엄격한 SQL 모드가 활성화되면 범위 초과 오류가 발생합니다. . mysql&gt; SET sql_mode = &#39;TRADITIONAL&#39;; mysql&gt; INSERT INTO t1 (i1, i2) VALUES(256, 256); ERROR 1264 (22003): Out of range value for column &#39;i1&#39; at row 1 mysql&gt; SELECT * FROM t1; Empty set (0.00 sec) . 엄격한 SQL 모드가 활성화되지 않은 경우 경고와 함께 클리핑이 발생합니다. . mysql&gt; SET sql_mode = &#39;&#39;; mysql&gt; INSERT INTO t1 (i1, i2) VALUES(256, 256); mysql&gt; SHOW WARNINGS; ++++ | Level | Code | Message | ++++ | Warning | 1264 | Out of range value for column &#39;i1&#39; at row 1 | | Warning | 1264 | Out of range value for column &#39;i2&#39; at row 1 | ++++ mysql&gt; SELECT * FROM t1; +++ | i1 | i2 | +++ | 127 | 255 | +++ . 엄격한 SQL 모드가 활성화되지 않은 경우 클리핑으로 인해 발생하는 열 할당 변환은 ALTER TABLE, LOAD DATA, UPDATE 및 다중 행 INSERT 문에 대한 경고로 보고됩니다. 엄격 모드에서는 이러한 명령문이 실패하고 테이블이 트랜잭션 테이블인지 여부 및 기타 요인에 따라 일부 또는 모든 값이 삽입되거나 변경되지 않습니다. 자세한 내용은 5.1.11절. “서버 SQL 모드”에서 참조하십시오. . 숫자 표현식 평가 중 오버플로로 인해 오류가 발생합니다. 예를 들어, 가장 큰 부호 있는 BIGINT 값은 9223372036854775807이므로 다음 표현식은 오류를 생성합니다. . mysql&gt; SELECT 9223372036854775807 + 1; ERROR 1690 (22003): BIGINT value is out of range in &#39;(9223372036854775807 + 1)&#39; . 이 경우 작업이 성공하려면 값을 unsigned로 변환합니다. . mysql&gt; SELECT CAST(9223372036854775807 AS UNSIGNED) + 1; +-+ | CAST(9223372036854775807 AS UNSIGNED) + 1 | +-+ | 9223372036854775808 | +-+ . 오버플로 발생 여부는 피연산자의 범위에 따라 다르므로 DECIMAL 값의 범위가 정수보다 크기 때문에 앞의 표현식을 처리하는 또 다른 방법은 정확한 값 산술을 사용하는 것입니다. . mysql&gt; SELECT 9223372036854775807.0 + 1; ++ | 9223372036854775807.0 + 1 | ++ | 9223372036854775808.0 | ++ . 하나가 UNSIGNED 유형인 정수 값 사이의 빼기는 기본적으로 부호 없는 결과를 생성합니다. 그렇지 않으면 결과가 음수였을 경우 오류가 발생합니다. . mysql&gt; SET sql_mode = &#39;&#39;; Query OK, 0 rows affected (0.00 sec) mysql&gt; SELECT CAST(0 AS UNSIGNED) - 1; ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#39;(cast(0 as unsigned) - 1)&#39; . NO_UNSIGNED_SUBTRACTION SQL 모드가 활성화된 경우 결과는 음수입니다. . mysql&gt; SET sql_mode = &#39;NO_UNSIGNED_SUBTRACTION&#39;; mysql&gt; SELECT CAST(0 AS UNSIGNED) - 1; +-+ | CAST(0 AS UNSIGNED) - 1 | +-+ | -1 | +-+ . 이러한 작업의 결과가 UNSIGNED 정수 열을 업데이트하는 데 사용되는 경우 결과는 열 유형의 최대값으로 잘리거나 NO_UNSIGNED_SUBTRACTION이 활성화된 경우 0으로 잘립니다. 엄격한 SQL 모드가 활성화되면 오류가 발생하고 열이 변경되지 않은 상태로 유지됩니다. . 11.2 날짜 및 시간 데이터 유형 . 11.2.1 Date and Time Data Type Syntax 11.2.2 The DATE, DATETIME, and TIMESTAMP Types 11.2.3 The TIME Type 11.2.4 The YEAR Type 11.2.5 Automatic Initialization and Updating for TIMESTAMP and DATETIME 11.2.6 Fractional Seconds in Time Values 11.2.7 Conversion Between Date and Time Types 11.2.8 2-Digit Years in Dates . 시간 값을 나타내는 날짜 및 시간 데이터 유형은 DATE, TIME, DATETIME, TIMESTAMP 및 YEAR입니다. 각 임시 유형에는 유효한 값 범위와 MySQL이 나타낼 수 없는 유효하지 않은 값을 지정할 때 사용할 수 있는 “0” 값이 있습니다. TIMESTAMP 및 DATETIME 유형에는 11.2.5절. “TIMESTAMP 및 DATETIME에 대한 자동 초기화 및 업데이트”에 설명된 특수한 자동 업데이트 동작이 있습니다. . 임시 데이터 유형의 저장 요구 사항에 대한 정보는 11.7절. “데이터 유형 저장 요구 사항”에서 참조하십시오. . 시간 값에 대해 작동하는 함수에 대한 설명은 12.7절. “날짜 및 시간 함수”를 참조하십시오. . 날짜 및 시간 유형으로 작업할 때 다음과 같은 일반적인 고려 사항을 염두에 두십시오. . MySQL은 표준 출력 형식으로 주어진 날짜 또는 시간 유형에 대한 값을 검색하지만 사용자가 제공하는 입력 값에 대한 다양한 형식을 해석하려고 시도합니다(예: 날짜 또는 날짜에 할당하거나 비교할 값을 지정할 때 시간 유형). 날짜 및 시간 유형에 대해 허용되는 형식에 대한 설명은 9.1.3절. “날짜 및 시간 리터럴”을 참조하십시오. 유효한 값을 제공해야 합니다. 다른 형식의 값을 사용하면 예측할 수 없는 결과가 발생할 수 있습니다. . | MySQL은 여러 형식으로 값을 해석하려고 시도하지만 날짜 부분은 항상 월-일-년 또는 일-월-보다는 년-월-일 순서(예: ‘98-09-04’)로 지정해야 합니다. 다른 곳에서 일반적으로 사용되는 연도 순서(예: ‘09-04-98’, ‘04-09-98’). 다른 순서의 문자열을 년-월-일 순서로 변환하려면 STR_TO_DATE() 함수가 유용할 수 있습니다. . | 2자리 연도 값을 포함하는 날짜는 세기를 알 수 없기 때문에 모호합니다. MySQL은 다음 규칙을 사용하여 2자리 연도 값을 해석합니다. . 70-99 범위의 연도 값은 1970-1999가 됩니다. | 00-69 범위의 연도 값은 2000-2069년이 됩니다. | . | . 11.2.8절. “2자리 연도”도 참조하십시오. . 한 시간 유형에서 다른 시간 유형으로의 값 변환은 11.2.7절. “날짜 및 시간 유형 간 변환”의 규칙에 따라 발생합니다. . | 값이 숫자 컨텍스트에서 사용되는 경우 MySQL은 날짜 또는 시간 값을 숫자로 자동 변환하고 그 반대의 경우도 마찬가지입니다. . | 기본적으로 MySQL은 범위를 벗어나거나 해당 유형에 대해 유효하지 않은 날짜 또는 시간 유형 값을 발견하면 값을 해당 유형의 “0” 값으로 변환합니다. 예외는 범위를 벗어난 TIME 값이 TIME 범위의 적절한 끝점으로 잘리는 것입니다. . | SQL 모드를 적절한 값으로 설정하면 MySQL이 지원하기를 원하는 날짜의 종류를 보다 정확하게 지정할 수 있습니다. (섹션 5.1.11, “서버 SQL 모드”를 참조하십시오.) ALLOW_INVALID_DATES SQL 모드를 활성화하여 MySQL이 ‘2009-11-31’과 같은 특정 날짜를 수락하도록 할 수 있습니다. 이는 향후 처리를 위해 사용자가 지정한(예: 웹 형식) “잘못된” 값을 데이터베이스에 저장하려는 경우에 유용합니다. 이 모드에서 MySQL은 월이 1에서 12 사이의 범위에 있고 일이 1에서 31 사이에 있는지만 확인합니다. . | MySQL에서는 DATE 또는 DATETIME 열에 일 또는 월과 일이 0인 날짜를 저장할 수 있습니다. 이것은 정확한 날짜를 알 수 없는 생년월일을 저장해야 하는 응용 프로그램에 유용합니다. 이 경우 날짜를 ‘2009-00-00’ 또는 ‘2009-01-00’으로 저장하면 됩니다. 그러나 이와 같은 날짜를 사용하면 완전한 날짜가 필요한 DATE_SUB() 또는 DATE_ADD()와 같은 함수에 대해 올바른 결과를 기대해서는 안 됩니다. 날짜에서 0월 또는 일 부분을 허용하지 않으려면 NO_ZERO_IN_DATE 모드를 활성화하십시오. . | MySQL에서는 ‘0000-00-00’의 “0” 값을 “더미 날짜”로 저장할 수 있습니다. 경우에 따라 이것은 NULL 값을 사용하는 것보다 더 편리하고 더 적은 데이터와 인덱스 공간을 사용합니다. ‘0000-00-00’을 허용하지 않으려면 NO_ZERO_DATE 모드를 활성화하십시오. . | 커넥터/ODBC를 통해 사용되는 “0” 날짜 또는 시간 값은 ODBC가 이러한 값을 처리할 수 없기 때문에 자동으로 NULL로 변환됩니다. . | . 다음 표는 각 유형에 대한 “0” 값의 형식을 보여줍니다. “0” 값은 특별하지만 표에 표시된 값을 사용하여 명시적으로 저장하거나 참조할 수 있습니다. 쓰기가 더 쉬운 ‘0’ 또는 0 값을 사용하여 이 작업을 수행할 수도 있습니다. 날짜 부분(DATE, DATETIME 및 TIMESTAMP)을 포함하는 시간 유형의 경우 이러한 값을 사용하면 경고 또는 오류가 발생할 수 있습니다. 정확한 동작은 엄격 및 NO_ZERO_DATE SQL 모드가 활성화된 경우에 따라 다릅니다. 5.1.11절. “서버 SQL 모드”를 참조하십시오. . Data Type “Zero” Value . DATE | ‘0000-00-00’ | . TIME | ‘00:00:00’ | . DATETIME | ‘0000-00-00 00:00:00’ | . TIMESTAMP | ‘0000-00-00 00:00:00’ | . YEAR | 0000 | .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/database/dbms/mysql/datatype/2021/11/01/post019.html",
            "relUrl": "/markdown/database/dbms/mysql/datatype/2021/11/01/post019.html",
            "date": " • Nov 1, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "파이썬 기반의 대규모 알고리즘 트레이딩 시스템 소개",
            "content": "Algorithm Trading System . 알고리즘 트레이딩 = 증권 업무 자동화 시스템 업무 : 증권, 자산운용 혼자서 돈을 버는 기계가 아니다. . 셀 사이드 vs 바이 사이드 . 바이 사이드 : 자산운용. 어떤 증권이 오를 것인가. 이 과정에서 컴퓨터 시스템과 알고리즘을 사용하는 것을 Quant Investment, 즉 퀀트 운용이라고 한다. 퀀트 운용은 알고리즘 트레이딩과 다르다. 퀀트 운용에는 퀀트 펀드, 전략 인덱스, 로보 어드바이저 등이 있다. 퀀트 운용에서는 주문이 나가지 않는다. 거래소랑 네트워크로 연결되어 있지 않다. 반면 알고리즘 트레이딩은 거래소와 연결이 되어 실제 주문을 내고 변경하고 취소하는 주문의 제어가 같이 이루어진다. 퀀트 전략 + 실제 네트워크를 통한 트레이딩이 시스템 트레이딩이다. 근데 시스템 트레이딩은 성격이 바이 사이드에 가깝다. 알고리즘 트레이딩에서 시스템 트레이딩이 차지하는 영역은 작다. 대부분은 대량 최적 집행과 HFT 마켓 메이킹이다. | . 알고리즘 트레이딩 . 대량 최적 집행(Optimal Execution) : 대량 주문을 쪼개서 보내는 것. 대표적인 것이 TWAP(Time Weighted Average Price) | 마켓 메이킹(Market Making) 유동성 공급(LP; Liquidity Providing) | 매수/매도 양방향 지정가 주문 지정가 주문(Limit Order) : FIFO Queue. 줄 서서 사거나 파는 사람들. | 시장가 주문(Market Order) : 큐에서 주문 체결(소모). 줄 서지 않고 바로 사거나 파는 사람들. 가격 필드는 없고 수량 필드만 주어진다. 만약 매수를 한다면 팔겠다는 FIFO Queue에 가서 내가 사고 싶은 수량만큼 사서 받아가는 것. 그럼 거래가 체결되는 것. 큐를 따라서 쭈욱 올라가는 것을 Sweeping이라고 함. 이런 스위핑을 보통 신문에서는 매매 사고라고 한다. | High Frequency Trading. 대부분은 시장가 주문을 한다. 누군가 지정가 주문으로 기다려줘야 한다. 근데 마켓 메이킹은 사겠다는 사람에겐 팔고 팔겠다고 하는 사람에겐 사는 역할을 해서 중간 센터같은 존재다. 다만 살 때는 싸게 사고 팔 때는 비싸게 판다. 사는 가격과 파는 가격의 차이를 스프레드라고 부른다. 수익 = 매수/매도 스프레드 * 거래량 리스크 관리 : 포지션/변동성/추세에 따른 스프레드 조정 | . | . | 일반적인 업무 자동화 시스템과의 차이점 핵심 비즈니스 로직(전략)이 고정되어 있지 않음. 변화하는 시장 상황에 따라 지속적인 업그레이드 필요 | 개별 사용자(트레이더) 별로 비즈니스 로직을 별도 개발 및 적용 | 사용 및 관리가 쉬운 스크립트 구현 선호 | . | 오작동 = 초대형 손실 다양한 테스트 환경 및 시나리오 요구 조건 필요 | . | . | . 알고리즘 트레이딩과 파이썬 . 분석 매매 단일 플랫폼 훌륭한 시장 분석 없이 훌륭한 매매 전략은 생기지 않는다 | 알고리즘 트레이딩의 파워는 자동화/대량처리를 통한 비용절감이다 | 매매에 필요한 파라미터를 수동으로 결정하면 자동화/대량처리 불가능 | 입력 실수로 인한 사고 위험 | . | 알고리즘 트레이딩이 원래의 파워를 발휘하려면 대규모의 실시간 병렬처리 시장분석 | 시장 분석 결과를 사용한 전략 파라미터 자동 결정 및 검증 | 대규모의 트레이딩 업무 및 운용전략 동시수행을 통한 비용 절감 | . | . | 그럼 왜 파이썬? 분석 매매 단일 플랫폼 구현 가능 다양한 분석 라이브러리 연동 | interacitve console 기반의 실시간 시장 분석 가능 | . | 전략(비즈니스 로직) 코드 개발 및 관리 개발 생산성 향상 | 클러스터 상에서 사용자의 비즈니스 로직의 관리/배포 용이 | . | 다양한 컴포넌트 연결 다양한 미들웨어, 데이터베이스 및 라이브러리 연결 용이 | . | . | . Python Technology Stack . 파이썬 시스템 - anaconda | 데이터베이스 - redis-py, pytables, pymongo, log4mongo | 자료 관리 및 분석 - numpy, pandas, statsmodels, ta-lib | 시각화 - matplotlib, seaborn | 실시간 시장분석 - ipython, jupyter | 메시지 미들웨어 - simplejson, ujson, pyzmq | Finite State Machine - fysom | 프로세스 관리 - psutil, apscheduler, fabric, supervisord | 사용자 인터페이스 - tornado, django | 시장 정보 . Tick Data 종목정보, 호가, 체결, 프로그램 매매, 투자자 정보 등 | 거래소로부터 전송되는 모든 실시간 시장정보 | 불규칙 샘플링 자료 | . | 일중 데이터(Intraday Data) 분봉 시고저종 | 분단위 샘플링 틱 데이터 | . | 일간 데이터(Daily Data) 일봉 시고저종 | 일단위 통계/분석 자료 | . | 시장정보 데이터베이스 &amp; API . 데이터의 종류가 다양해서 데이터베이스의 종류도 다양. 3가지 종류의 데이터베이스 시스템. . 인메모리 디비 : 틱데이터 실시간 처리. 레디스. | HDF5 : 과거 틱 데이터 저장. | MongoDB : 분봉, 분석 데이터 등. 틱 데이터는 실시간으로 message-oriented middleware를 통해 전송되고 다른 데이터들은 각각의 타입에 따라서 api를 만들어 놓음. | 시장 정보 API . 시장 정보 종류별 데이터베이스 클래스 지원 | 모든 시장정보는 pandas DataFrame 형식으로 출력 TickDb Class : In-Memory Database에 저장된 당일의 실시간 틱 데이터 | HistoricalTickDb Class : HDF5 Database에 저장된 과거 틱 데이터 | DailyDb 클래스 : MongoDB에 저장된 당일 및 과거의 시장 분석 데이터 | | . TickDb Class . method - 기능 순 code_st() : 주식 종목정보 code_fo() : 선물옵션 종목정보 code_id() : 지수 종목정보 code_br() : 거래원 정보 ticker_st() : 주식 티커 목록 ticker_fo() : 선물옵션 티커 목록 isin_st() : 주식 isin 목록 isin_fo() : 선물옵션 isin 목록 is_in_ticker_st() : 주식티커 확인 is_in_ticker_fo() : 선물옵션 티커 확인 is_in_isin_st() : 주식 isin 확인 is_in_isin_fo() : 선물옵션 isin 확인 isin2inst() : isin-종목유형 변환 isin2ticker() : isin-ticker 변환 ticker2inst() : ticker-종목유형 변환 ticker2isin() : ticker-isin 변환 get_isin2inst() : isin-종목유형 map get_isin2ticker() : isin-ticker map get_ticker2inst() : ticker-종목유형 map get_ticker2isin() : ticker-isin map session() : 장정보 trade_st() : 주식 체결 틱 히스토리 trade_fo() : 선물옵션 체결 틱 히스토리 quote_st() : 주식 호가 틱 히스토리 quote_fo() : 선물옵션 호가 틱 히스토리 minute_st() : 주식 분봉 히스토리 minute_fo() : 선물옵션 분봉 히스토리 program_st() : 주식 프로그램 매매 히스토리 broker_st() : 주식 거래원 히스토리 index() : 지수 히스토리 list_methods() : 클래스 메소드 목록 list_members() : 클래스 멤버 목록 . HistoricalTickTb Class - 과거 틱 데이터 . 과거 틱데이터 액세스 | TickDb와 동일한 메소드 지원 | 시뮬레이션을 위한 추가 메소드 set_date() : 날짜 지정 set_time() : 시간 지정 | 과거의 특정 시각에 시장을 보는 것과 같은 효과 | . DailyDb Class - 과거 시장 분석 데이터 . 틱 데이터의 분단위 스냅샷 | 분봉 및 일봉 | 시장 모형 기반의 분석 자료 code_st() : 주식 종목정보 code_fo() : 선물옵션 종목정보 code_id() : 지수 종목정보 intraday_st() : 주식의 분단위 스냅샷 데이터 intraday_fo() : 선물옵션의 분단위 스냅샷 데이터 intraday_id() : 지수의 분단위 스냅샷 데이터 daily_st() : 주식의 일단위 데이터 daily_fo() : 선물옵션의 일단위 데이터 daily_id() : 지수의 일단위 데이터 | . Message . Message-Oriented Middleware 기반의 통신 현재 ZeroMQ, Formula 미들웨어 지원 | 복수 미들웨어 동시 사용 가능 | 실시간 시장/주문 정보는 FIX 프로토콜에 기반한 JSON 문자열 | . | 메시지 처리상의 주의점 모든 메시지는 시계열 정보(time series)이므로 병렬처리 불가 | 시장 정보의 경우에는 최신(lastest)의 정보만 처리해야함. 시장 정보 큐(queue)에 복수 정보가 있을 경우 과거 정보 삭제 | . | . 이벤트 기반 전략 . 이벤트 = 실시간 시장 및 주문 정보 | 알고리즘 트레이딩 시스템 = 복합 이벤트 처리 시스템 | . 전략 구현 클래스 라이브러리 . BaseStrategy 베이스 클래스 | Component 클래스 Event | Socket | 원주문(Meta-Order) | 버퍼(Buffer) | 주문(Order) | 체결(Trade) | 포지션(Position) | 종목별 손익(Asset) | 전체 손익(Book) | . | . 이벤트 처리 함수의 구현 방법 . 방법 1 : 전략 클래스의 이벤트 핸들러 메소드 오버라이드 수신되는 이벤트의 유형에 따라 호출되는 이벤트 핸들러 메소드가 미리 정해져 있음. | 특정 이벤트 메소드를 오버라이드 구현하여 원하는 동작 실현 | . | 방법 2 : 이벤트 필터 전략의 상태(Finite State)와 수신 이벤트의 유형의 조합으로 이벤트 핸들러 선택 | 복수의 이벤트 핸들러 수행 가능 | 이벤트 핸들러를 동적으로 추가/제거 가능 | . | . 틱데이터 기반 백테스트(Back-test) . 성능 평가 및 사고 예방을 위한 필수 과정 | 실시간 코드와 동일한 전략 코드로 틱 이벤트 기반의 백테스트 | In-the-Loop 방식이 아닌 시뮬레이션 방식의 백테스트 지원 실제 통신을 하지 않고 직접 이벤트 핸들러 호출 | 테스트 병렬처리, 속도, 배치 프로세싱, 디버그 브레이크 | 타이머 시뮬레이션 가능 backtest_set_datetime() : 백테스트를 시작할 일시 지정 backtest_set_breaktime() : 백테스트를 중지할 일시 지정 backtest_step() : 1개의 이벤트 처리 backtest_go() : 미리 지정한 중지 시점까지 처리 | . | . PEG &amp; LAYERING . Layering : 지정가 주문을 여러 호가에 분할 | Pegging : 호가가 변화하는 경우 최우선 호가로 추종 | .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/algorithm-trading/trading/python/2021/10/19/post018.html",
            "relUrl": "/markdown/algorithm-trading/trading/python/2021/10/19/post018.html",
            "date": " • Oct 19, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "이것이 MySQL이다",
            "content": "Chapter 01 DBMS 개요와 MySQL 소개 . 1.1 DBMS 개요 . 1.1.1 데이터베이스의 정의와 특징 . 데이터베이스는 여러 명의 사용자나 응용 프로그램이 공유하고 동시에 접근이 가능해야 한다. | 유명한 DBMS로는 MySQL, MariaDB, Oracle, SQL Server가 있다. | DBMS의 특징이 있다. 데이터의 무결성 데이터베이스 안의 데이터는 어떤 경로를 통해 들어왔던지 데이터에 오류가 있으면 안된다. | . | 데이터의 독립성 데이터베이스의 크기를 변경하거나 데이터 파일으 ㅣ저장소를 변경하더라도 기존에 작성된 응용 프로그램은 전혀 영향을 받지 않아야 한다. | . | 보안 | 데이터 중복의 최소화 | 응용 프로그램 제작 및 수정이 쉬워짐 | 데이터의 안전성 향상 DBMS가 제공하는 백업, 복원 기능을 이용할 수 있다. | . | | . 1.1.2 데이터베이스의 발전 . 오프라인으로 관리 | 파일시스템의 사용 파일이 커지면 한계가 명확해진다. | . | DBMS(DataBase Management System) ‘데이터베이스’를 잘 관리하고 운영하기 위한 시스템 또는 소프트웨어를 의미. | SQL(Structured Query Language)의 등장 | . | . 1.1.3 DBMS의 분류 . 크게 4~5가지로 분류. 핵심은 RDBMS. | 계층형 DBMS. 트리구조로 되어 있음. | 망형 DBMS. 수평으로도 연결되어 있음. 현재 사용하지 않음. | 관계형 DBMS(RDBMS). 시초는 1969년. 최소 단위는 테이블임. 엑셀 sheet가 테이블. 관계형 DBMS의 핵심 구조. 열 = 컬럼, 행 = 로우 | . | . 1.1.4 SQL 개요 . RDBMS를 유지하기 위한 언어. 하지만 DBMS 제작 회사와 독립적임. 표준 SQL이 있음. 오라클은 표준 SQL을 지키면서 PL/SQL을 만듦. . 다른 시스템으로 이식성이 좋다. | 표준이 계속 발전한다. | 대화식 언어다. | 분산형 클라이언트/서버 구조를 지원한다. | . 1.2 MySQL 소개 . Oracle에서 제작함. 개정판에서는 MySQL 8.0 버전을 사용함. . 1.3 MySQL의 에디션 및 기능 비교 . 회사에서 사용할 거면 사용 에디션을 사용하면 된다. 우리가 아는 커뮤니티 버전은 엔터프라이즈 정도 기능을 갖고 있다. . Chapter02 MySQL 설치 . 2.1 MySQL 설치 전 준비사항 . 2.1.1 소프트웨어 요구사항 . 64비트 윈도우즈. 윈도우즈 10. 우리는 MySQL Server, MySQL Client, MySQL Workbench, Samples and Examples를 설치할 것. root는 MySQL의 관리자. | 클라이언트 프로그램으로 MySQL Workbench가 있다. 웹 브라우저랑 비슷한 개념. 웹 서버에 접속하기 위해 브라우저를 이용하는 것처럼 데이터베이스에 접속하기 위해 워크벤치를 쓰는 것. | Edit &gt; Preferences &gt; SQL Editor에서 마지막을 체크 푼다. | C: Program Files MySQL MySQL Server 8.0 bin 복사. | Powershell을 관리자 권한으로 열고 cmd 명령어 입력 | SETX PATH “C: Program Files MySQL MySQL Server 8.0 bin;%PATH%” | . 2.3 샘플 데이터베이스 설치 . cmd 창에서 mysql -u root -p : root user로 password를 입력해서 접속하겠다라는 의미. | source employees.sql; : employees.sql 파일을 실행한다. | . 2.4 설치 후 확인해야 할 사항 . 2.5 MySQL 제거 . 2.6 Linux에 MySQL을 설치하기 . 현장에서는 리눅스에서 더 많이 사용한다. | . Chapter 03 MySQL 전체 운영 실습 . 3.1 요구사항 분석과 시스템 설계 그리고 모델링 . 3.1.1 정보시스템 구축 절차 요약 . 요구사항 분석, 설계, 구현, 시험, 유지보수 5가지 단계. 3.1.2 데이터베이스 모델링과 필수 용어 . 데이터베이스 모델링은 현실세계에서 사용되는 데이터를 MySQL에 어떻게 옮겨 놓을 것인지 결정하는 것. . | 열에는 데이터 형식이 있다. | 기본키는 PK(Primary Key). 기본키는 중복이 없다. 그리고 Null 값이 들어올 수 없다. | 테이블은 데이터베이스에 담아야 한다. 데이터베이스는 데이터의 저장소이다. | . 3.2 데이터베이스 구축 . 3.2.1 데이터베이스 생성 . 데이터베이스 생성 -&gt; 테이블 생성 -&gt; 데이터 입력 -&gt; 데이터 조회/활용 스키마와 데이터베이스는 같은 용어. 우리는 쇼핑몰 데이터베이스를 만들 예정. .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/database/dbms/mysql/2021/10/18/post017.html",
            "relUrl": "/markdown/database/dbms/mysql/2021/10/18/post017.html",
            "date": " • Oct 18, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "내가 정리하는 트레이딩",
            "content": "트레이딩도 결국 사업 . 식당 창업을 할 때 기본적으로 분석해야 하는 것이 상권분석, 요식업 트렌드 트렌드 분석 등이다. 마찬가지로 트레이딩을 할 때에는 시장과 자기 자신에 대한 분석을 해야한다. | 요식업에서도 기본을 지키며 고객들에게 최선의 서비스를 제공한다면 성공하리라는 믿음이 있다. 마찬가지로 트레이딩에서도 규율을 지키며 시장과 함께 간다면 장기적으로 성공한다. | 매매 계획과 전략은 요리 레시피와 같다. 레시피가 매번 바뀌지 않듯이 전략은 쉽게 안된다. 전략을 요리라고 생각하자. 요리가 맛있는지 없는지 검증하는 것이 반드시 필요하듯이 전략도 검증 단계를 반드시 거쳐야 한다. | 식당의 목표는 돈을 버는 것이 아닌, 요리의 퀄리티, 즉 맛과 서비스를 고품질로 유지하는 것이다. 마찬가지로 트레이딩의 목표는 시장에서 승리하는 것이 아니라 위험자산을 잘 관리하는 것이다. | 시장이 어떻게 움직일지 미리 예단하지 말것이다. 대신, 구체적인 플랜을 세워 시장의 움직임에 대해 대처하라. 고객의 클레임은 언제 어떻게 나타날 지 모른다. 따라서 항상 기본을 지킨 자세로 대처할 준비를 해야 한다. | . 체크포인트 . 어떤 시장에 진입할 것인가 | 어떤 종목에 진입할 것인가 | 타임프레임은 어느 정도인가 | 언제 진입할 것인가(진입시점) | 어떻게 진입할 것인가(분할매수) | 진입 자본의 크기는 어느 정도인가 | 진입 시 손절 포인트는 언제인가 | 애드업은 언제할 것인가 | 애드업은 얼만큼 할 것인가 | 언제 청산할 것인가(청산시점) | 어떻게 청산할 것인가(분할매도) | 승률은 어떠한가 | 손익비는 어떠한가 | 이익률은 어떠한가 | . 위험관리 . 리스크 관리는 내 욕심을 조절하는 행위다. 리스크와 리턴은 비례한다. 즉 리스크가 클수록 수익도 클 가능성이 높다. 따라서 리스크를 관리하는 것은 기대하는 수익의 크기를 관리하는 것이다. 내가 한 번에 큰 돈을 벌고 싶다면, 그만큼의 큰 위험을 감수하는 것이다. | 리스크 관리의 목적은 시장에서의 생존이다. 생존이 담보된 이후에 꾸준히 이익을 내야 한다. 즉 꾸준이 이익을 내는 수준의 리스크만 부담해야 한다는 것이다. 이 말은 자금 관리가 리스크 관리의 많은 부분을 차지한다는 뜻이다. | .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/trading/2021/10/07/post016.html",
            "relUrl": "/markdown/trading/2021/10/07/post016.html",
            "date": " • Oct 7, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "시스템 트레이딩 강의",
            "content": "메인보드 .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/online-lecture/computer-science/2021/09/27/post015.html",
            "relUrl": "/markdown/online-lecture/computer-science/2021/09/27/post015.html",
            "date": " • Sep 27, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "오태민의 5분 경제학",
            "content": "오태민의 5분 경제학 . 1. 의사결정공식(조수아벨의 사례) .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/online-lecture/economics/2021/09/08/post014.html",
            "relUrl": "/markdown/online-lecture/economics/2021/09/08/post014.html",
            "date": " • Sep 8, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "뇌를 단련하다",
            "content": "뇌를 단련하다 by 다치바나 다카시 . 개강에 즈음하여 두어 가지를 일러두며 . . 제 1회 . 환경, 나, 우주 . ‘첫경험’을 앞둔 여러분에게 . 세 개의 위상으로 생각한다 . 일본의 이과 교육은 19세기 이전 수준 . 지의 구조 변화가 모든 것을 움직인다 . . 제 2회 . 대학은 지의 확대재생산 과정의 최전선 . 여러분은 아직 어느 누구도 아니다 . 자기 뇌는 스스로 만들어라 . . 제 3회 . 아인슈타인의 뇌를 분석해보니 . 전두엽에 인간이 존재한다 . 뇌에 좋은 환경 . . 제 4회 . 강의는 ‘제끼기’를 위해서 존재한다 . 모르면 더욱 읽어라 . 고바야시 히데오도 헤맸다 . 정확성이라는 열병 . R부인에 대한 사랑이 발레리를 낳았다? . 이십대 청년에게 갑자기 패러다임의 대전환이 찾아왔다 . 권위를 의심하라 . . 제 5회 . 학생시절의 노트에서 . 정신의 혁명, 르네상스 . 자기 유형을 찾아내라 . . 제 6회 . 사전을 통째로 읽어본다 . 유급을 권함 . 교양이란 리버럴 아트 . . 제 7회 . 이대로 가면 일본의 ‘지’가 쇠퇴한다 . 사이언스와 테크놀로지의 리터러시 . 거시적 시각에서 총체를 바라보면 . . 제 8회 . 세상의 모든 것은 에너지의 흐름 . 자기조직화 원리는 발견되는가? . 캠브리지의 만찬회 . . 제 9회 . 시간과 공간의 관념을 뒤집은 슈퍼 이론 . 상대성이론을 무기로 자연의 비밀을 찾는다 . 우주의 근본원리란? . . 제 10회 . 세계를 보는 시각이 완전히 바뀌었다 . 상식의 벽을 깨부수다 . 스승에게 반기를 들다 . 지구도 설탕 알갱이도 대칭적으로 이루어져 있다 . . 제 11회 . 대칭성이란 무엇인가? . 젊은 중국인 과학자의 도전 . 대칭성의 파괴가 세계를 만들었다 . . 제 12회 . 백과사전에 오른 가문 . 기억해두면 유익한 한 마디 . 소설가와 뇌 의학자 .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/bookreview/self-development/2021/09/04/post013.html",
            "relUrl": "/markdown/bookreview/self-development/2021/09/04/post013.html",
            "date": " • Sep 4, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "모닝루틴 및 취침전루틴",
            "content": "Morning Routine . 눈이 떠지면 기지개를 편다. | 잠 기운을 없애기 위해 팔굽혀펴기를 가볍게 20개 한다. | 꿈에 대해 회상해보고 기록한다. | 화장실에 가서 소변을 보고 가글을 한다. | 1분 동안 찬물샤워를 하고 온 몸의 세포를 깨운다. 단, 바디워시는 사용하지 않는다. | 유산균과 함께 물을 한 컵 마신다. | 우유오트밀과 닭가슴살을 먹는다. | 양치를 한다. | 오전 명상을 한다. | 당일의 목표와 해야 할 일 및 하루 계획을 점검한다. | 감사일기를 적는다. | 30분간 독서한다. | 목표를 이룬 모습을 생생하게 상상해본다. | 거울을 보면서 자신감 포즈를 취한다. | 비타민과 영양제를 먹는다. | 오전 운동을 하러 나간다. | Before Bed Routine . 하루의 목표치와 성공 여부를 체크한다. | 잘한 점 및 보완해야할 점, 생각 등을 기록한다. | 내일 해야 할 일들을 정리한다. | 명상을 한다. | 숙면용 소리를 틀고 취침한다. |",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/plan/morning-routine/2021/08/27/post012.html",
            "relUrl": "/markdown/plan/morning-routine/2021/08/27/post012.html",
            "date": " • Aug 27, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "개발 관련 잡다한 팁 모음",
            "content": "Git에서 origin 바꾸기 . git remote set-url origin https://[Personal Access Token]@github.com/sangwon-woo/[repository].git . VS Code Keyboard Shortcut for Mac . 아래에 줄 추가(Insert Line Below): Shift + Command + Enter | 위에 줄 추가(Insert Line Above): Shift + Enter | Delete: fn + Backspace | 단어 하나 왼쪽 삭제(Delete Word Left): Option + Backspace | 단어 하나 오른쪽 삭제(Delete Word Right): fn + Option + Backspace | 왼쪽 끝까지 삭제(Delete All Left): Control + k | 오른쪽 끝가지 삭제(Delete All Right): Control + l | 위에 커서 추가(Add Cursor Above): Option + Command + Upkey | 아래에 커서 추가(Add Cursor Below): Option + Command + Downkey | 터미널 창 토글(View: Togle Panel): Command + j | 위에 줄 복사(Copy Line Up): Shift + Option + Upkey | 아래에 줄 복사(Copy Line Down): Shift + Option + Downkey | 줄 삭제(Delete Line): Shift + Command + k | 마크다운 프리뷰(Markdown: Open Preview to the Side): Command + k v | . Cross Platform Framework . 윈도우, 리눅스와 같은 운영체제에 상관없이 같은 코드로 각 운영체제에서 동작하는 프로그램을 지원하는 것을 의미. . PyQt5 . Qt라는 GUI 프레임워크의 파이썬 바인딩. 키움 Open API+는 OCX(Object Linking and Embedding Custom Control) 방식을 사용하는데, PyQt 패키지의 QAxContainer 모듈을 통해 OCX를 사용. PyQt에서 위젯은 사용자 인터페이스를 구성하는 가장 기본적인 부품 역할을 함. 사용자 인터페이스를 만들기 위해 QGroupBox, QLabel, QTextEdit, QDateEdit, QTimeEdit, QLineEdit와 같은 다양한 위젯이 사용됨. PyQt에서는 다른 위젯에 포함되지 않은 최상위 위젯을 특별히 윈도우(Window)라고 함. PyQt에서 윈도우를 생성하기 위한 클래스로 QMainWindow나 QDialog 클래스가 일반적으로 사용됨. . 이벤트 처리 | . 클래스 변수, 인스턴스 변수 . class Parent: house = &#39;yong-san&#39; # 클래스 변수 def __init__(self): self.money = 10000 # 인스턴스 변수 . 파이썬에서 Sqlite3 사용하기 . import sqlite3 con = sqlite3.connect(&#39;데이터베이스 파일의 경로 및 이름을 지정&#39;) # con이라는 객체를 통해 데이터베이스를 조작 cursor = con.cursor() # 커서는 SQL 구문을 호출 할 때 사용됨 cursor.execute(&#39;SQL 구문을 입력&#39;) # execute 메서드를 사용해서 구문을 호출 cursor.commit() cursor.execute(&#39;SELECT * FROM test_table;&#39;) cursor.fetchall() # 한 번에 모든 로우를 읽기 cursor.fetchone() # 로우 단위로 읽기 cursor.close() # 커서 종료 . pandas DataFrame 객체를 SQLite DB에 저장하기 . import sqlite3 con = sqlite3.connect(&#39;~/test.db&#39;) df = DataFrame(test) df.to_sql(&#39;test&#39;, con) # test라는 이름의 테이블 . 참고로 to_sql은 아래와 같다 . DataFrame.to_sql(name, con, flavor=&#39;sqlite&#39;, schema=None, if_exists=&#39;fail&#39;, index=True, index_label=None, chunksize=None, dtype=None) . name : SQL Table 이름으로 파이썬 문자열 형태로 나타낸다. | con : cursor 객체 | flavor : DBMS를 지정할 수 있다. ‘sqlite’ 또는 ‘mysql’을 사용할 수 있다. 기본값은 ‘sqlite’다. | schema : Schema를 지정할 수 있다. 기본값은 None이다. | if_exists : 데이터베이스에 테이블이 존재할 때 수행 동작을 지정한다. ‘fail’, ‘replace’, ‘append’ 중 하나를 사용할 수 있는데 기본값은 ‘fail’이다. ‘fail’은 데이터베이스에 테이블이 있다면 아무 동작도 수행하지 않는다. ‘replace’는 테이블이 존재하면 기존 테이블을 삭제하고 새로 테이블을 생성한 후 데이터를 삽입한다. ‘append’는 테이블이 존재하면 데이터만 추가한다. | index : DataFrame의 index를 데이터베이스 컬럼에 추가할지 여부를 지정한다. 기본값은 True다. | index_label : 인덱스 컬럼에 대한 라벨을 지정할 수 있다. 기본값은 None이다. | chunksize : 한 번에 써지는 로우의 크기를 정수값으로 지정할 수 있다. 기본값은 None으로 DataFrame 내의 모든 로우가 한 번에 써진다. 많은 로우가 있을 때 데이터베이스 한 번에 쓰는 경우 패킷 크기 제약으로 에러가 발생할 수 있다. 이럴 땐 다음과 같이 하면 된다. df.to_sql(&#39;test&#39;, con, chunksize=1000) . | dtype : 컬럼에 대한 SQL 타입을 Python Dicktionary로 전달할 수 있다. | . SQLite Table에서 df로 데이터 로드하기 . import pandas as pd import sqlite3 con = sqlite3.connect(&#39;~/~.db&#39;) df = pd.read_sql(&#39;SELECT * FROM kakao&#39;, con, index_col = None) # 또는 index_col = &#39;index&#39; . PyCharm의 디버깅 기능 . Step Over(F8) : 코드의 현재 라인에서 그 다음 라인으로 이동한다. 하이라이트 표시된 라인이 메서드를 호출하고 있어도 다음 줄로 넘어간다. 호출된 메서드는 내부적으로 실행된다. 다만 내부적으로 실행되는 메서드라도 해당 메서드에 breakpoints가 존재할 경우 디버거는 해당 위치에서 정지한다. 이 때 강제로 스킵하고 싶으면 Force Step Over를 사용하면 된다. . | Step Into(F7) : 메서드 내에서 무슨 일이 일어나고 있는지 보여준다. 호출한 메서드가 올바른 결과를 반환하고 있는지 확신할 수 없을 때에 이 기능을 사용해서 메서드 내부를 관찰할 수 있다. . | Step Into My Code(Alt + Shift + F7) : 나의 코드에 집중하고 싶을 때, 라이브러리 클래스로는 stepping 하지 않고 Step Into를 수행하는 기능이다. . | Step Out(Shift + F8) : 메서드를 호출하던 바깥 코드로 빠져나온다. . | . Python GUI . 이벤트 순환문은 GUI를 작동시키는 메커니즘이다. GUI는 이벤트가 전달되기를 기다리는 무한 루프라고 생각할 수 있다. 버튼을 클릭하면 GUI 내부에서 이벤트를 생성하거나 GUI크기를 재조정하는 이벤트를 생성한다. | ttk 모듈에는 GUI를 멋지게 보이게 하는 노북, 프로그레스바, 라벨과 색다른 버튼과 같은 고급 위젯이 있다. 이는 GUI를 더 멋지게 만들어 준다. 어떤 면에서 ttk는 tkinter 패키지 내의 확장이다. | GUI는 이벤트 중심이다. 버튼을 클릭하면 이벤트가 발생한다. ttk.Button 위젯의 command 속성을 사용해 콜백함수에서 이 이벤트가 발생할 때 일어나는 일을 바인드한다. | 클라이언트 코드에 의해 호출되지 않는 비공개 함수임을 나타내기 위해 quit 함수 앞에 밑줄을 하나 붙이는 파이썬 명명규칙을 사용한다. | . import 경로 및 파일 부를 때 경로 . import 할 때는 해당 python script의 디렉터리를 기준으로 부른다. | script 내에서 static file을 읽을 때는 current working directory(os.getcwd()를 보면 됨)를 기준으로 부른다. | . Python Script에서 MySQL 연결하기 . import mysql.connector # create dictionary to hold connection info dbConfig = { &#39;user&#39;: &#39;Pacific&#39;, # your user name &#39;password&#39;: &#39;tkddnjs!1301&#39;, # your password &#39;host&#39;: &#39;127.0.0.1&#39;, } conn = mysql.connector.connect(**dbConfig) print(conn) conn.close() . *args와 **kwargs . *args의 경우 갯수를 알 수 없는 여러 인자를 함수 내부에서 tuple 형태로 받는다. | **kwargs의 경우 갯수를 알 수 없는 ‘키’=’값’ 인자를 함수 내부에서 dictionary 형태로 받는다. | list, tuple type의 변수를 *args를 갖는 함수에 넘겨줄 때는 *list, *tuple 형태로 unpack해서 넘겨줘야 한다. | dictionary type의 변수를 **kwargs를 갖는 함수에 넘겨줄 때는 **dict 형태로 unpack해서 넘겨줘야 한다. | . MySQL . Database | Schema | Table | MySQL에서 데이터베이스랑 스키마랑 동일한 의미. 하지만 다른 DBMS에서는 스키마와 데이터베이스가 동일한 용어가 아님. | . os module . import os fDir = os.path.dirname(__file__) # 현재 실행되는 파일이 속해있는 디렉터리 netDir = fDir + &#39; Backup&#39; if not path.exists(netDir): makedirs(netDir, exist_ok=True) . 요구사항 분석과 시스템 설계 그리고 모델링 . 정보시스템 구축 절차 요약 정보시스템을 구축하기 위해서는 일반적으로 분석, 설계, 구현, 시험, 유지보수의 5가지 단계를 거친다. | . 분석 단계 - 시스템 분석 또는 요구사항 분석. 우리가 무엇what을 할 것인지 결정. | 설계 단계 - 시스템 설계 또는 프로그램 설계. 우리가 어떻게how 할 것인지 결정. | 구현 단계 - 프로그래머가 설계서에 나온 그대로 프로그램을 작성. | . | | 데이터베이스 모델링 데이터베이스 모델링 - 현실세계에서 사용되는 데이터를 MySQL에 어떻게 옮겨 놓을 것인지를 결정하는 과정. | . | | 데이터베이스 구축 절차 데이터베이스 생성 | 테이블 생성 | 데이터 입력 | 데이터 조회/활용 | . | | . 데이터베이스 인스턴스 . Instance는 MySQL 프로그램이 컴퓨터에서 활성화되어 있는 서비스를 말한다. 그래서 일반적으로 MySQL 서버, MySQL 서비스, MySQL 인스턴스 등 모두를 MySQL로 보면 된다. | . 데이터베이스 개체 . Table | Index | View | Sotred Prodecure | Trigger | . vim . i : 입력모드 | h, j, k, l : 좌, 하, 상, 우 | w : 저장 | q : 나가기 | w : 단어나 문장부호 단위로 뛰기(정방향) | W : 띄어쓰기 단위로 뛰기(정방향) | e : 단어끝이나 문장부호 끝 단위로 뛰기(정방향) | E : 띄어쓰기 끝 단위로 뛰기(정방향) | b : 단어나 문장부호 단위로 뛰기(역방향) | B : 띄어쓰기 단위로 뛰기(역방향) | 0 : 해당 라인의 첫 번째 칸으로 가기 | $ : 해당 라인의 끝으로 가기 | ^ : 해당 라인의 첫 글자로 가기 | f 누르고 내가 찾고 싶은 key 입력 : 찾고 싶은 key로 이동 | t 누르고 내가 찾고 싶은 key 입력 : 찾고 싶은 key 앞칸으로 이동 | F, T : 역방향 | ; : 전에 했던 명령어를 수행(f, t를 수행한 후, 정방향) | , : 전에 했던 명령어를 수행(f, t를 수행한 후, 역방향) | / : 찾고자 하는 단어. enter를 누르면 전체 하이라이트. 이 상태에서 n누르면 다음 단어로 이동, N 누르면 다음 단어로 역방향 이동. | *, # : 커서가 위치한 단어를 전체 찾기. | . Mbps, MB, MiB . Mbps = Mega Bit Per Second | 100Mbps = 최대 12MB/S | bps는 1초당 전송할 수 있는 비트의 수를 의미한다. | MB = Megabyte | 10의 6제곱 | 저장매체에서 사용하는 단위. | MiB(메비바이트) = Mebibyte | 1 MiB = 2의 20제곱 = 1,048,576 바이트 | 1TB 저장매체는 대략 931 GiB | . Anaconda 가상환경(base) 자동활성화 해제 . conda activate base (base) conda config --set auto_activate_base false . Anaconda 가상환경에서 mysql connector 설치 및 사용 . pip install mysql-connector-python . import mysql conn = mysql.connector.connect(user=&#39;root&#39;, password=&#39;1234&#39;, host=&#39;127.0.0.1&#39;) .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/programming/cookbook/tip/software/2021/08/25/post011.html",
            "relUrl": "/markdown/programming/cookbook/tip/software/2021/08/25/post011.html",
            "date": " • Aug 25, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "공부하는 뇌",
            "content": "공부하는 뇌 by 다니엘 G.에이멘 . 추천의 말 . . 프롤로그 .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/bookreview/brain/science/self-development/2021/08/23/post010.html",
            "relUrl": "/markdown/bookreview/brain/science/self-development/2021/08/23/post010.html",
            "date": " • Aug 23, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "주식 투자의 지혜",
            "content": "주식 투자의 지혜 by 천장팅 . 추천의 말 . . 프롤로그 . . 들어가며 . . 1장 도전, 주식투자 . 주식투자와 인생 . 특별한 도박장 . 개인 투자자는 왜 실패할까? . 주식 분석에 필요한 기본 지식 . . 2장 주식 분석에 필요한 기본 지식 . 기본적 분석을 위한 기본 지식 . 기술적 분석을 위한 기본 지식 . 주식 분석에 대한 나의 생각 .",
            "url": "https://sangwon-woo.github.io/dailyblog/trading/quant/2021/08/17/post009.html",
            "relUrl": "/trading/quant/2021/08/17/post009.html",
            "date": " • Aug 17, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "마지막 몰입",
            "content": "마지막 몰입 by 짐 퀵 . 들어가며 . . 제 1부 왜 우리는 스스로 평범하다고 생각할까? . 제 1장 슈퍼히어로 이전의 삶에서 깨닫지 못한 것들 . 나는 뇌가 고장 난 소년이었다 . 인생에 처음으로 쓴 버킷리스트 . 그동안 잘못된 질문을 해온 걸까? . 지식은 ㅎ미이고 학습은 초능력이다 . 꿈에 그리던 슈퍼히어로 학교에 가다 . 이제 지금의 나는 잊어라 . 마인드셋, 동기, 방법이 핵심이다 . 마인드셋(무엇): 우리가 어떤 사람인지, 세상이 어떻게 돌아가는지, 우리가 무엇을 할 수 있고 무엇이 가능한지에 대한 신념과 태도 또는 가정. | 동기(왜): 행동을 취하는 목적. 특정 방식으로 행동하는 데 필요한 에너지. | 방법(어떻게): 어떤 것을 달성하기 위한 구체적인 과정. 정돈되고 논리적이고 체계적인 지시. | . . 제 2장 습관을 나쁘게 길들이는 디지털 빌런의 등장 . 우리를 쉴 수 없게 만드는 정보의 홍수 . 몰입할 에너지를 뺏는 멀티태스킹 . 기억력을 갉아먹는 디지털 아웃소싱 . 무의식적인 클릭은 생각의 근육을 없앤다 . 문제의 해결은 의식하는 데서 시작된다 . . 제 3장 ‘나는 할 수 없어’라는 생각의 함정 . 해내겠다는 욕망은 반드시 나를 바꾼다 . 우리의 기분과 행동을 좌우하는 숨은 힘 . 뇌와 장이 당신의 멘탈을 결정한다 . 스스로 배우고 가르치는 시대가 온다 . 천재가 남긴 단서에 성공의 답이 있다 . . 제 4장 짧은 시간 안에 원하는 것을 얻는 법 . 무엇이든 쉽고 빠르게 배우는 FASTER 기법 . 나를 넘어서겠다는 결심이 들었다면 . 원하는 것에 몰입하고 싶다면 질문하라 . 당신의 머릿속을 꽉 채운 질문은 무엇인가 . 올바른 질문은 지식을 힘으로 바꾼다 . . 제 2부 낡은 마인드를 완전히 리셋하라 . 제 5장 자신에 대한 잘못된 편견을 없애라 . 우리의 뇌는 생각보다 똑똑하다 . ‘나는 여기까지야’라는 생각에 자꾸 지는 이유 . 누구에게나 천재성은 있다 . 긍정적인 사람이 더 건강한 이유 . 나를 가두는 잘못된 신념에서 벗어나기 . 첫 번째 열쇠: 제한적 신념에 이름을 붙여라 | 두 번째 열쇠: 사실을 확인하라 | 세 번째 열쇠: 새로운 신념으로 대체하라 내 안의 비평가를 침묵시키는 법 . 제한적 신념은 가장 나쁜 습관이다 . | . 제 6장 나의 잠재력을 가두는 일곱 가지 거짓말 . 거짓말 1. 지능은 타고나는 것이다 . 거짓말 2. 우리는 뇌의 10%만 쓴다 . 거짓말 3. 실수가 곧 실패다 . 거짓말 4. 아는 것이 힘이다 . 거짓말 5. 새로운 것은 쉽게 배울 수 없다 . 열쇠는 작고 단간한 단계를 하나씩 밟아가는 것이다. . 거짓말 6. 다른 사람의 조언을 들어야 한다 . 거짓말 7. 천재는 따로 있다 . 거짓의 우물에 자신을 밀어 넣지 않으려면 . . 제 3부 몰입해야 할 이유를 반드시 발견하라 . 동기의 공식 : 동기=목적∗에너지∗S3동기 = 목적 * 에너지 * S^3동기=목적∗에너지∗S3 . S^3 = Small Simple Steps . 제 7장 모든 것은 ‘왜?’에서 시작된다 . 목표를 발견하게 하는 마법의 질문 . 열정은 목적을 부른다 . ‘나는 이런 사람이다’라는 말의 힘 . 인생의 우선순위를 정하라 . 재밌는 일도 이유가 없으면 하지 않게 된다 . 인생의 우선순위를 정하라 . 재밌는 일도 이유가 없으면 하지 않게 된다 . 고통은 나를 앞으로 나아가게 만든다 . 동기는 결국 내 안에서 찾아야 한다 . 새로운 경험으로 열정에 불을 붙인다 . . 제 8장 끝까지 해내려는 두뇌 에너지가 필요하다 . 좋은 음식에서 에너지를 얻어야 한다 . 몸을 움직여라, 뇌도 움직인다 . 머릿속을 어지럽히는 ‘개미’ 없애기 . 청소와 정리는 온몸의 감각을 깨운다 . 긍정적인 사람을 가까이하라 . 하나뿐인 뇌를 철저히 보호하라 . 새로운 것을 배워야 뇌가 성장한다 . 주기적으로 스트레스를 관리하라 . 충분한 수면이 보약이다 . 건강한 뇌를 위한 레시피 . . 제 9장 행동하게 만드는 습관 설계가 필요하다 . 먼저 나 자신에게 친절해지기 . 하루에 한 걸음, 일을 잘게 나눠라 . 습관의 고리를 만드는 ‘자동 조종 모드’ . 나쁜 습관, 없애지 말고 대체하라 . 새로운 습관을 만드는 WIN 기법 . 아주 작은 습관이 당신을 바꾼다 . 반드시 아침 루틴을 만들어라 . 더 나은 오늘을 위한 습관 만들기 . . 제 10장 목표를 향한 강렬한 몰입이 필요하다 . 몰입에 이르는 것이 성공의 열쇠다 . 동기부여의 소스 코드, 몰입의 4단계 . 온전히 집중하기 위한 다섯 가지 조건 . 몰입을 방해하는 악당을 저지하라 . 제대로 몰입해본 적 있는가? . . 제 4부 잠재력을 터뜨려 지금의 나를 넘어서라 .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/bookreview/self-development/2021/08/17/post008.html",
            "relUrl": "/markdown/bookreview/self-development/2021/08/17/post008.html",
            "date": " • Aug 17, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "나만의 명언 목록",
            "content": "나는 책을 좋아한다. 그러다보니 책을 읽다가 마음에 드는 문구나 명언을 여러번 만나곤 한다. 하지만 기록하거나 외운 적이 없어서 1회성 만남으로 그치는 경우가 대다수였다. 운이 좋아 친구들이나 주변 지인들에게 내가 받았던 감명깊은 부분을 전달하면 가끔씩 내 머릿속에 다시금 떠올라올 뿐이었다. 이제는 명언도 기록해야겠다. 내가 좋아한 다는 것은 나의 가치관과 연결되어 있다는 것이니깐. 전반적인 가치관의 틀을 시각화하기 위해서라도 꾸준히 진행해야 할 것임에 틀림없다. . . 생산성이란 더 많은 일을 해내는 것이 아니라 옳은 일을 해내는 것이다. . 마이클 하야트의 초생산성 p.28에 나오는 말이다. 생산성에 대해서 잘못 알고 있었던 부분을 깨닫게 해준 명언이다. . . 더 오래 산다고 죽음을 이기는 것이 아니다. 잘 살고, 꽉찬 삶을 사는 것으로 죽음을 이기는 것이다. . 태어나서 죽기 전까지 무엇을 할 것인가. 죽음은 누구에게나 온다. 죽음은 삶 만큼 흔하다. 그렇다면 내가 죽음을 대하는 태도는? 랜디 교수 말대로 오래 산다고 죽음을 피하는 것이 아니다. 지금 이 순간을 충실하게 가득 채움으로써 죽음을 피할 수 있다. . 후회는 이미 해본 것들에서 오는 것이 아니라 하지 못한 것 때문에 온다. | 물질에서 열정을 찾을 수 없다. | . 21세기의 문맹은 읽고 쓰지 못하는 이들이 아니다. 오히려 배운 것을 원점으로 되돌린 후, 새롭게 배우는 것을 못하는 이들이다. by 앨빈 토플러 . 새롭게 배우지 못하는 사람들이 많다. 스스로가 너무 똑똑하고 아는 것이 많다고 생각해서 발생하는 교만일까. 아니면 단순히 호기심이 부족해서 그런 것일까. 무엇이든지 간에 새로운 것에 대해 배우고자 하는 마음이 없다면 남은 미래는 안봐도 뻔하다. .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/self-development/maxim/golden-saying/2021/08/17/post007.html",
            "relUrl": "/markdown/self-development/maxim/golden-saying/2021/08/17/post007.html",
            "date": " • Aug 17, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "초생산성",
            "content": "초생산성 by 마이클 하얏트 . 들어가며 . . Step 1. 멈춰라 . . 1장 수립하기: 원하는 것을 결정하라 . 목표 1: 효율성 . 목표 2: 성공 . 목표 3: 자유 . 옳은 일을 하는 것 . 여러분의 비전은 무엇인가 . . 2장 평가하기: 나아갈 방향을 설정하라 . 열정과 능숙도의 교차점 . 생산성의 네 영역 . 자신의 진북 찾기 . 제한적 믿음, 해방적 진실 . . 3장 회복하기: 몸과 마음의 활력을 되찾아라 . 실천 1: 수면 . 실천 2: 식사 . 실천 3: 운동 . 실천 4: 대인관계 . 실천 5: 놀이 . 실천 6: 성찰 . 실천 7: 일 플러그 뽑기 . 자신을 새롭게 하라 . . Step 2. 잘라내라 . . 4장 제거하기: ‘아니오’ 근육을 키워라 . 시간의 역학 이해하기 . 얻는 것이 있으면 잃는 것도 있다는 사실 받아들이기 . 자신의 책무 여과하기 . ‘안 할 일 목록’ 만들기 . 새로운 일 거절하기 . 이미 맡은 책무에서 벗어나기 . 가지치기 과정 축하하기 . . 5장 자동화하기: 등식에서 빠져나와라 . 자기 자동화 . 템플릿 자동화 . 과정 자동화 . 기술 자동화 . 쉬운 방법을 찾아라 . . 6장 위임하기: 나 또는 더 나은 나를 복제하라 . 잠깐, 잠깐… . 위임의 위계 . 위임을 절차 . 위임의 다섯 레벨 . 시간을 되찾아라 . . Step 3. 행동하라 . . 7 통합하라: 이상적인 1주일을 계획하라 . 대량 일괄 처리의 힘 . 이상적인 1주일 계획하기 . 더욱 생산적인 리듬 . . 8장 지정하기: 업무의 우선순위를 매겨라 . 다음 주 미리 검토하기: 주간 프리뷰 . 하루 설계하기: 일간 빅3 . 시간 경계 세우기 . . 9장 활약하기: 방해물과 산만함을 물리쳐라 . 방해물: 침입 . 산만함: 도피 . 집중 전략 . 우리는 아이솔레이터가 없어도 된다 .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/bookreview/self-development/2021/08/16/post006.html",
            "relUrl": "/markdown/bookreview/self-development/2021/08/16/post006.html",
            "date": " • Aug 16, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "서른과 마흔 사이",
            "content": "서른과 마흔 사이 by 오구라 히로시 . 프롤로그 . . 1장 낡고 오래된 습관을 떠나지 못하는 당신에게 . 01 땅만보고 걷는 자, 결코 멀리 가지 못한다 . 02 과거에게 먹이를 주지 마라 . 03 행운의 어머니는 불운이다 . 04 리프레이밍의 기술을 익혀라 . 05 눈앞에 존재하는 것에 몰입하라 . 06 한 권의 책을 100번 읽어라 . 07 멋지고 당당하게 삼진을 당하라 . 08 선순환을 만들어라 . 09 일상을 철저하게 정돈하라 . 10 심플하고 담백한 삶을 살아라 . . 2장 지나간 인생을 돌려받고 싶은 당신에게 . 01 소신과 자존심으로 똘똘 뭉쳐라 . 02 한 번 더 넘어져라 . 03 기준은 내 안에 있다 . 04 고통도 구원도 모두 당신의 몫이다 . 05 프로야구 선수의 승률이면 충분하다 . 06 완벽함은 모자람만 못하다 . 07 세상은 숨기지 않는 사람에게 열려 있다 . 08 ‘근거 없는 자신감’을 권하는 이유 . 09 내 믿음보다 강한 것은 없다 . 10 실패할 리스크를 각오하라 . . 3장 처음 한 걸음을 내딛기 어려운 당신에게 . 01 몸을 일으키는 건 새로운 깨달음이다 . 02 오래된 상처와 당당하게 만나라 . 03 티핑 포인트를 만드는, start small! . 04 우공이산이 이긴다 . 05 매일 0.2%라도 자신의 최고 기록을 갱신하라 . 06 매일 한 편의 시를 읽어라 . 07 확실한 것은 없지만 확신은 있다 . 08 메일 박스만 정리해도 인생이 달라진다 . 09 ‘must’를 ‘want’로 바꿔라= . 10 자아도취의 습관을 길러라 . . 4장 상대가 내 뜻대로되지 않아 고민하는 당신에게 . 01 상대에게 완벽을 바라지 마라 . 02 타인은 나를 비춰주는 거울이다 . 03 사랑받으려면 사랑하라 . 04 기대하고 원망하지 마라 . 05 먼저 이해하고 나중에 이해시켜라 . 06 ‘소중한 것들’에 우열은 없다 . 07 나를 위한 변명을 멈춰라 . 08 상대를 움직이는 사과의 기술은 따로 있다 . 09 아름다운 마음을 자극하라 . 10 연결고리를 발견하라 . . 5장 인간관계에서 어려움을 겪는 당신에게 . 01 인생의 가장 큰 밑천은 사람이다 . 02 잃는 것은 한 순간, 되찾는 데는 평생이 걸린다 . 03 인간은 명예를 위해서라면 목숨도 내던진다 . 04 30대의 8할은 인간관계다 . 05 과거는 결코 사라지지 않는다 . 06 큰소리로 비난하지 마라 . 07 불성실한 마음은 상대에게 뻔히 보인다 . 08 진심으로 눈과 마음을 기울여 듣는다 . 09 아무리 사소한 약속이라도 함부로 하지 않는다 . 10 사람이 어려울 땐 부모님을 찾아뵈어라 . . 6장 결심한 일을 지속하지 못하는 당신에게 . 01 nothing의 시체를 높이 쌓지 마라 . 02 1만 시간의 법칙을 따라라 . 03 성공은 무욕과 과욕 사이에 있다 . 04 점수를 매기지 않는 경기는 없다 . 05 목표를 세분화하라 . 06 최강의 툴은 ‘시각화’의 활용이다 . 07 ABC 이론을 철저하게 지켜라 . 08 1m만 더 뛰어라 . 09 신이 주신, 다시 찾아온 기회를 놓치지 마라 . 10 절대 남몰래 숨어서 하지 마라 . . 7장 꿈과 목표를 발견하지 못한 당신에게 . 01 파랑새는 멀리 있지 않다 . 02 커리어 드리프트를 활용하라 . 03 행운은 분투하는 자의 전유물이다 . 04 오토크라인을 적극 분비시켜라 . 05 1년은 미쳐라 . 06 때로는 도망치는 것도 전략이다 . 07 매달 ‘꿈’을 업그레이드하라 . 08 플러스 사이클을 만들어라 . 09 계획할 시간을 계획하는 것부터 시작하라 . 10 위대한 수첩을 만들어라 .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/bookreview/self-development/2021/08/15/post005.html",
            "relUrl": "/markdown/bookreview/self-development/2021/08/15/post005.html",
            "date": " • Aug 15, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "가진 돈은 몽땅 써라",
            "content": "가진 돈은 몽땅 써라 by 호리에 다카후미 . 프롤로그 . . 1. 마인드셋 - ‘안전제일’이 가장 위험한 시대 . 15년을 달려 마침내 우주에 도달하다 . 살아 숨 쉬는 돈의 행복 . 제일 먼저 손을 번쩍 드는 사람이 되라 . 중요한 건 조직이 아니라 나 자신 . 나는 집 살 돈으로 자유를 샀다 . 빌려준 돈은 이미 버린 돈이다 . 생명보험 대신 금융공부 . . 2. 행동 혁명 - 원 없이 놀아본 사람만이 한계를 뛰어넘는다 . 일단 무엇이든 시작해야 의욕도 생긴다 . ‘용돈’에 맞춰 살지 말고 ‘계획’에 맞춰 산다 . 죽을 때까지 자기관리를 해야 하는 이유 . 모텔 말고 이왕이면 고급 호텔로 . 재미있는 술자리는 무조건 간다 . 결실이 없는 이유는 몰두하지 않았기 때문 . 주식도 부동산도 결국은 도박 . 잘 노는 것이 역량이 되는 시대 . 가족에 헌신, 안 할 수 있으면 하지 마라 . . 3. 시간 혁명 - 돈으로 살 수 있는 시간은 몽땅 사라 . 아이디어만 있다면 돈은 얼마든지 빌려도 된다 . 나는 지갑도 없고 현금도 없다 . 청소와 빨래는 전문가에게 . 당신이 사는 곳이 당신의 삶을 결정한다 . 사람을 잘 다루는 사람 주위에 인재가 몰려든다 . 출퇴근 2시간 = 월급 20% 삭감 . 택시비도 안 되는 일은 하지 마라 . 유능한 사람일수록 돈보다 시간이 귀중하다 . . 4. 습관 혁명 - 절약과 인내에도 비용이 든다 . 점심 메뉴는 고민 말고 장어덮밥 . 스마트폰은 언제나 최신형, 최고 스펙으로 . ‘꺾이지 않는 마음’의 지지대는 체력이다 . 시대를 읽는 ‘사고 근육’ 단련법 . 세상에 ‘아무거나 괜찮은’ 것은 없다 . 용기도 돈처럼 타이밍에 맞게 아낌없이 써라 . ‘소중한 물건’이라는 것도 결국 환상일 뿐이다 . . 5. 커리어 혁명 - 당신의 돈을 브랜드로 바꾸는 법 . 공적은 남에게 넘겨라 . 내가 누구에게나 밥을 잘 사는 이유 . 사냥꾼은 갖고 싶은 것 앞에서 망설이지 않는다 . 1을 100으로 만드는 ‘투자형 사고’ . 남에게 잘 기대는 능력도 필수다 . 이제는 아이디어가 아니라 속도 싸움이다 . “부자가 되면 뭐하시게요?” . 균형을 깨고, 있는 힘껏 방망이를 휘둘러라 . 돈으로 해결할 수 없는 문제 . 즐거움이 줄어드는 선택은 하지 않는다 . . 에필로그 .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/bookreview/self-development/2021/08/14/post004.html",
            "relUrl": "/markdown/bookreview/self-development/2021/08/14/post004.html",
            "date": " • Aug 14, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "슈퍼러너 공부법",
            "content": "슈퍼러너 공부법 by 조나단 레비 . . 1장 정보 과부하와 지식의 폭발 . 무엇을 배울지 선택할 수 있을 뿐만 아니라 이를 비교적 쉽게 흡수하는 방법이 있다. 나아가 이를 오래 기억하는 방법도 있다. . 이 책의 목표. 무엇을 배울지 선택하고, 빠르게 흡수하고, 오래 기억하는 방법. . . 2장 배움에 있어서 가장 중요한 기술 . 효과적으로 학습(effective learning)하면 무엇이든 배우고 원하는 뭐든지 될 수 있다. . 맞는 말이다. 학교에서는 효과적으로 학습하는 방법을 알려준 적이 없다. 뒤늦게라도 가속학습에 대해 알게 된 것이 다행이라 생각한다. 이미 많은 사람들이 이에 대해 공부하고 연습해서 자신의 삶에 적용하고 있다는 것을 알고있다. 남은 것은 가속학습에 대해 배운 것을 꾸준히 실천하는 것일 뿐이다. . . 3장 원시인처럼 배워보자 . 호모 사피엔스인 인간은 특히 선명하고(vivid), 시각적이며(visual), 경험적인(experiential) 학습을 하도록 적응되어왔다. . 과학자들은 이런 현상을 “그림 우월성(picture superiority effect)”라고 명명했다. 이미지로 기억하는 게 중요하다. 인간은 이미지를 잘 기억한다. 그렇다면 학습 할 때 뇌에서 어떤 일이 일어나는가. . . 4장 성인은 어떻게 학습해야 하는가 . 손에 잡히는 학습, 즉 경험에 의한 학습은 성인학습에 있어서 유일한 조건이다. . 경험하기 전까진 절대 알 수 없다는 말과 일맥상통. 동기의 필요조건 - 토대, 배고아자 하는 욕구, 당장의 활용성, 방향성, 자아개념, 동기 . 토대 . 성인 학습자들은 무언가를 배울 때 과거의 지식 및 경험을 적극 활용해야 한다. 새롭게 배우는 정보를 우리가 이미 아는 정보와 비교 및 대조할 줄 알아야 한다. . 배우고자 하는 욕구 . 우리는 학습의 원인을 좀 더 실용적이고 기능적인 데서 찾으려 한다. ‘왜 특정 정보가 가치 있는가’를 아는 것만으로는 부족하다. ‘그 정보를 어떻게 활용할 것인가’, ‘우리의 목적 성취에 그 정보가 도움이 되는가’가 중요하다. 즉 특정 정보가 어떻게 현실에 적용되는지를 고려하는 것만으로도 학습의 집중력 및 기억력이 향상될 수 있는 것이다. . 당장의 활용성 . 성인은 활발한 연습 및 참여가 있을 때 가장 잘 배울 수 있다. 따라서 학습 경험을 이에 맞도록 고안해야 한다. 가장 좋은 방법은 그 정보를 직접 사용하는 것이다. . 한 마디로 Learning by doing. . 방향성 . 놀스는 성인들은 문제를 직접 맞닥뜨린 후 해결책을 찾아가는 게 최선의 학습법임을 깨달았다. 성인은 학습 과정에서 문제 위주 대 문제 해결 위주의 방향성에 주의를 기울일 필요가 있다. 정보를 활용하고 현실적인 응용방법을 생각하는 것이 효과적 학습에 필수적이다. . 실전 문제 및 도전 문제를 푸는 게 최선의 학습법이라는 말. . 자아 개념 . 선경험과 실용적 응용에 더해, 성인의 학습법에는 필요조건이 더 있다. 바로 ‘적극적인 참여’다. 성인학습자들은 배움의 장에서 학습 계획 및 평가에 직접 참여할 필요가 있다. 각자가 놓인 상황에 맞는 결정을 내리고, 자신의 학습 경험을 타인의 것과 비교해야 한다. . 동기 . 학습을 해서 얻을 큰 목표가 있어야 한다. 내재 동기가 있어야 한다. 학습에 대한 동기는 내면에서, 즉 앞서의 5가지 필요조건으로부터 우러나와야 한다. 뭔가를 배우려는 동기를 만들고 싶다면 왜 그런지 자신의 내면을 깊이 들여다볼 필요가 있다. 왜 그것을 배우길 원하는가. 배운 것을 어떻게 활용할 것인가. 이것을 배우면 삶에 어떤 보탬이 될까 . 토대, 배우고자 하는 욕구, 당장의 활용성, 방향성, 자아 개념. 잘 생각해놓자. 근데 배우고자 하는 욕구랑 당장의 활용성이 잘 구분안된다. 배우고자 하는 욕구는 뭔가 이 정보가 나에게 어떤 도움이 될지 미리 생각하는 거고, 당장의 활용성은 그 정보를 당장 써보는 것이구나. . . 5장 모든 공부에는 준비가 필요하다 . 열정을 가지는 것은 좋지만, 계획 없는 학습은 득보다 실이 되는 경우가 많다. . 내가 대부분 계획없이 학습하다가 망한 케이스다. . 해체(Deconstruction): 대상을 배움의 가장 기초적인 유닛으로 어떻게 세분화할 수 있는가? 예를 들면 개별 단어 및 문법 같은 유닛으로. 선별(Selection): 그 중 어떤 20%의 유닛들이 내게 80%의 이득을 가져다 줄 수 있는가?(파레토의 법칙) 순서(Sequencing): 이 유닛들을 배우는 가장 이상적인 순서는 무엇인가? 조건걸기(Stakes): 심리적 요인 및 사회적 압박 등을 어떻게 이용해서 학습시간을 단축하고 스스로를 더 빨리 배우도록 채찍질할 것인가? . 팀 페리스의 가속학습 준비단계. . 특정 학습 프로젝트에 뛰어들기 전 고려해야 할 질문들 내가 왜 이 지식을 익히는가? - 우리가 무엇에 집중해야 하는가를 결정하는 데 도움 어느 정도 레벨의 지식이 필요한가? - 학습의 깊이에 따라 학습 접근법 및 예상시간이 달라짐 특정 지식을 어떻게 세분화할 수 있는가? 도 세분화된 지식들은 더 큰 카테고리 및 테마로 어떻게 다시 재결합할 수 있는가? 내 개인적 목표에 비추어 배워야 할 가장 중요한 것들은 무엇인가? - 파레토의 법칙. 학습에서 80% 정도의 노력은 아낄 수 있음. 이 지식을 배우는 데 적절한 순서는 무엇인가? - 학습의 순서는 정말 중요하다. 이 지식에 실제로 어떻게 접근할 것인가? 당신의 학습 스케줄은 어떤 형태이며, 어떻게 학습시간을 압축할 것인가? - 강제점을 찾아서 주입하자. 학습 성과를 어떻게 측정하고 추적할 것인가? - SMART라는 학습 목표. 가장 효율적인 학습 목표는 구체적이고(Specific), 측정가능하며(Measurable), 야심차고(Ambitious), 현실적이며(Realistic), 구체적 시간을 기반(Time-based)으로 한다. SMART 개념을 알아두면 자신의 학습 과정을 제대로 모니터링 할 수 있다. 측정만으로도 성과는 개선될 수 있지만, 측정 내용이 보고까지 된다면 학습 겅과는 일취월장할 수 있다. 학습이 계획했던 대로 진행되지 않는다면? - 최고의 학습 관리자들은 간헐적 실패를 미리 예상해둔다. 2번 빼먹지 마라. . 총 9개의 질문. 학습에 앞서서 성공적인 학습 계획을 세우는 것부터 연습해야 한다. 학습 계획에 쏟는 시간이 많아질수록 학습 시간은 줄어들 것이다. . . 6장 기억력을 10배 증가시키는 비결 . 해마(hippocampi)의 주된 임무는 기억할 가치가 있는 것들을 파악하고, 나머지는 몽땅 지워버리는 일이다. 해마 덕분에 우리의 뇌는 놀랍도록 망각에 적응을 잘한다. . 해마가 기억 중추라고 한다. 그리고 망각을 할 수 있게 만들어준다고 한다. .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/bookreview/self-development/2021/08/14/post003.html",
            "relUrl": "/markdown/bookreview/self-development/2021/08/14/post003.html",
            "date": " • Aug 14, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "부자의 길을 선택하다",
            "content": "부자의 길을 선택하다 by 리샤오라이 . 프롤로그 . . Chapter 1 ‘경제적 자유란’ 무엇일까’ . 01 삶의 ‘코스트라인’을 넘어서는 법 . 02 복리곡선은 당신 인생에도 적용된다 . 03 ‘경제적 자유’란 무엇일까? . 04 처음에는 누구나 서투르다 . 05 당신의 ‘비즈니스 모델’에 대해 고민해본 적 있는가? . 06 주어진 시간을 한 번 파는 사람 . 07 주어진 시간을 여러 번 파는 사람 . 08 타인의 시간을 사서 다시 파는 사람 . . Chapter 2 당신은 부자의 눈을 갖고 있는가? . 09 당신의 ‘운영체제’에 대해 생각해본 적 있는가? . 10 당신이 가진 가장 소중한 자산은 무엇인가? . 11 주의력의 효율성을 높이는 과학적인 방법 . 12 당신이 원하는 미래를 쟁취하기 위해 가장 필요한 능력 . 13 100% 안전감을 버렸을 때 비로소 보이는 것 . 14 내가 비트코인에 지속적으로 투자할 수 있었던 이유 . 15 당신은 ‘귀인’의 도움을 받을 준비가 되어 있는가? . 15 세상의 피드백을 받아들이는 용기 . . Chapter 3 부자의 길로 가는 방향 찾기 . 17 현재를 사는 사람 vs 미래를 사는 사람 . 18 ‘자기 증명’보다 중요한 ‘자기 성장’ . 19 불평은 무능함과 무력함의 표현일 뿐이다 . 20 시장을 보는 가치관이 나의 운명을 결정한다 . 21 부자가 되기 위해 가장 필요한 요소인 인내심 . 22 위기감이 없는 사람은 시장에서 도태되고 만다 . 23 인생의 경계를 뛰어넘는 순간을 캐치하는 법 . 24 당신이 아닌 세상이 필요로 하는 것을 읽어라 . . Chapter 4 투자형 인간이 되기 위한 마인드셋 . 25 ‘나와는 상관없다’는 생각을 버려라 . 26 ‘뭔가를 이룬 사람’을 가까이하라 . 27 매일 스스로 ‘뇌를 씻는’ 것을 게을리 하지 말라 . 28 아무도 가르쳐주지 않는 것을 스스로 배우는 단계로 진입하라 . 29 문제의 해결책을 빠르게 찾는 법을 기억하라 . 30 노력과 버티기로 유지하는 삶에서 벗어나라 . 31 서투름을 능숙함에 이르게 하는 ‘반복’의 힘을 믿어라 . . Chapter 5 투자의 기회를 잡는 방법 . 32 투자와 운의 상관관계를 기억하라 . 33 돈과 자본의 차이를 알아야 투자에 성공한다 . 34 실천보다 더 중요한 것은 없다 . 35 돈이 없을 때 투자를 훈련하라 . 36 투자는 모험으로 돈을 버는 것이 아니다 . 37 투자가 아닌 ‘도박’을 하고 있는 순간을 경계하라 . 38 ‘미리 알았다면 달라졌을 것’이라는 환상에서 벗어나라 . 39 시장 단기 예측의 무의미함을 깨달아라 . 40 ‘주기’를 이해하면 ‘추세’가 보인다 . 41 투자와 관련된 숙제는 반드시 투자 전에 끝내라 . . Chapter 6 내 안의 부자를 깨우는 길 . 42 선택의 질을 높이는 방법을 훈련하라 . 43 ‘장기’와 ‘성장률’을 결합하여 사고하는 방법을 배워라 . 44 당신이 받아들일 수 있는 ‘장기’의 기간을 최대한 늘려라 . 45 최대한 젊었을 때부터 투자에 관심을 가져라 . 46 끊임없이 배우고 지식 사이의 연결점을 늘려라 . 47 투자 성공을 이끌 ‘무기’를 끊임없이 연마하라 . 48 행동에 옮기는 것을 방해하는 심리적 요인을 제거하라 . 49 ‘인지의 업그레이드’를 게을리하지 말라 . 50 당신 자신이 최고의 부가가치 자산임을 기억하라 . . 에필로그 ‘투자형 인간’으로의 진화를 완성하는 법 . . 작가 후기 .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/bookreview/self-development/2021/08/14/post002.html",
            "relUrl": "/markdown/bookreview/self-development/2021/08/14/post002.html",
            "date": " • Aug 14, 2021"
        }
        
    
  
    
        ,"post19": {
            "title": "간단한 생각",
            "content": "2021-08-14 . 나의 목표 : 나의 목표는 무엇일까. | 나는 어떻게 살아야 하지? 앞으로 무엇을 하면서 살아야 할까. | 나의 먼 미래는 어떤 모습일까. | 나에게 지금 당장 필요한 것은 무엇일까 | 지금 당장 해야하는 가장 중요한 일은 무엇일까. | 먼 미래의 죽기 직전의 내가 지금의 나로 환생했다고 가정하자. 모든 기억은 없지만 내가 환생했다는 사실만 안다고 해보는 거다. 그렇다면 내가 지금처럼 행동하면서 살까? | 나에게 계획은 없었다. 그냥저냥 살아왔던 것인데.. 나의 목표와 이를 이루기 위한 계획을 세워야 한다. | 근본부터 다시. 내가 생각하는 나만의 프레임을 만들어야겠다. 나만의 운영체제. 신념과 가치관. | 계획을 잘 세워보자. 어떻게? | 나는 정말 무엇을 원하는가? 단순히 돈을 많이 벌고 싶은걸까? 아니면 돈을 벌고 난 뒤의 뭔가를 원하는 것일까. | 세상에는 단 하나의 진실된 약속이 존재한다. 언젠가는 죽는다는 것. 죽음은 별로 두렵지는 않다. 언젠가 마주해야 할 순간이 반드시 올 것임을 알고 있기 때문이다. | 내가 정말 잘 하고 싶은 것은 알고리즘 트레이딩이다. 알고리즘 트레이딩은 프로그래밍과 트레이딩 기법이 심리싸움이 녹아있어야 한다. | 깊게 생각해보고 판단해보자. 사실 지금까지 나 혼자의 사고로 깊게 생각해본적은 많이 없다. 깊게 정말 깊게 고민하는 활동을 해보자. | . 2021-08-15 . 정말 중요한 것 무엇보다도 가족과 연인, 친구, 동료. 결국 내사람들. . 건강(육체적 측면) 음식 식단 | 영양제 | . | 운동 러닝 | 라이딩 | 등산 | 헬스 | 스트레칭(유연성 증대) | . | . | 건강(정신적 측면) 명상 | 일기 | 독서 | 사색 | . | 마인드셋(Mindset) | 동기부여(Motivation) | 방법(Method) | 계획(Plan) | 2021-08-26 . 그냥 하고 싶은 일에 깊게 몰두하고, 나머지 것들은 차단해버리는 게 속 편할 듯. 우선 알고리즘 트레이딩 시스템을 닥치는 대로 만들어보자. 이미 기성세대들이 오프라인을 장악했다. 내가 집중해야 하는 곳은 새로운 시장이다. 앞으로 뜰 거 같은.. 행복의 4중주 - 엔돌핀, 세로토닌, 도파민, 옥시토신 . 2021-08-31 . 오늘 잠실M타워 1214호 계약 이제 남은 것은 이전 사무실에서 책과 컴퓨터와 모니터를 가져오는 것. 주말동안 짐을 좀 갖다놓아야겠다. . 책을 읽을수록, 유투브를 볼수록 뭔가 바보가 되는 느낌. 모두 그들의 삶. 그 속에서 타산지석으로 삼아야 하는 것을 발견해야 하지만 그 전에 나는 어떤 것을 원하는지 정의하는 게 우선일듯. 나는 어떤 삶을 살고 싶은것일까. 단순히 돈이 많이 생기면 그게 다일까? 이 세상에 어떤 도움이 되고 싶은 걸까. 가치를 창출하는 것. 창작하는 것. 새로운 것을 만들어내는 것. 하지만 다른 사람들에게 도움이 되는 것. 장기적인 안목으로 내 삶을 바라보면 당장의 걱정거리는 별로 필요없다. 나침반을 만들어야 한다. 내 길을 내가 찾아야 한다. 체면(Saving Face)을 살리는 걸 당연하다고 생각하지 말자. 나는 무엇을 위해 지금까지 이렇게 살아왔는가. 곰곰히 생각해보면 대부분 체면치레였다. 내가 진정 원했던 것은 아니었어. 내가 진짜 해보고싶고, 진짜 원하는 것은.. . 2021-09-05 . 삶의 의미는 가족이다. 가족이라 함은 나의 가족이 건강하고 행복한 삶을 영위하도록 최대한 돕는다는 것을 의미한다. 이것에는 나의 삶의 태도와 방향이 담겨 있다. 다만 가족이 있기 위해선 내가 먼저 있어야 한다. 그것은 양보할 수 없는 진실이다. 그렇다면 여기에 나는 있는가. 삶의 의미를 내 속이 아닌 내 밖에서 찾은 것 아닌가. 또한 언젠간 이별이 있을텐데 그 이후의 삶의 의미는 무엇이겠는가. 아직은 잘 모르겠다. 하지만 이것을 영원불변하는 삶의 기준으로 꼭 가져가야 하는 법도 없다. 그저 현재 내 상황과 현실에 맞게 내 삶의 의미를 찾았을 뿐이다. 남은 것은 빠르게 돈을 버는 것이다. 돈 보다 중요한 것은 시간이고, 시간보다 중요한 것은 나의 집중력이기 때문에 쓸 데 없는 것에 내 주의를 빼앗기지 말자. 내가 지금 해야 할 일과 앞으로 해야 할 것 외에 다른 것에 신경을 돌리는 것은 가족에게 해를 끼치는 행동이라고 여기자. 사실 나도 알고 있다. 나는 굉장히 외부의 영향을 많이 받는 사람이라는 것을. 이제는 인정하고 더 이상 고민하지 말고 해야 할 일에 집중하자. . 2021-09-06 . 오늘은 사무실 이사를 하는 날이다. 앞으로 무엇을 해야 하는가. . 교대 사무실에 있는 모든 짐들을 종합운동장 사무실로 옮긴다. | 종합운동장 사무실의 크기를 실측한다. 데스크 및 책장 등을 고려해서 구조를 생각해본다. 접이식매트리스 | 온수매트리스 | 블라인드 | 식사용 테이블 | 화이트보드 | . | 영등포 집에 있는 개발, 컴퓨터, 트레이딩, 투자 관련 서적을 종합운동장 사무실로 옮긴다. | 송파구로 전입신고를 한다. | 오금역 근처에 있는 퍼시스 매장으로 간다. | 사무용 데스크를 구매한다. | 2021-09-10 . 사람들이 명품을 사는 이유는 과시욕일 수도 있으나 사실은 더 깊은 내면의 무엇인가가 있는 듯 보인다. 신세계 백화점 강남점을 가보니 명품으로 치장한 수 많은 사람들을 볼 수 있었다. 물론 대다수는 여성이었다. 왜 그들은 백화점에 명품을 치장하고 나타날까? 이들은 백화점이 아닌 곳에서도 명품을 입고 다닐까? 백화점은 이제 그들의 런웨이가 되었다. 백화점에선 명품이 없으면 소외된다. 그들 무리에 끼려면 명품을 살 수 밖에 없는 것이다. 그렇다면 왜 백화점이 그들의 런웨이로 변했을까. 백화점이 어떤 신호를 보내는 것일까. 요즘 백화점, 특히 명품관을 가보면 굉장히 고급스럽다는 느낌이 든다. 인테리어도 예쁘고 시설도 깔끔하다. 백화점 명품관은 하나의 놀이터가 된 것이다. 다만 굉장히 고급스럽고 기품있는 곳이라는 신호를 사람들에게 보내는 것이다. 사람들도 이 신호에 맞춰서 다른 사람들에게 신호를 보낸다. 특히 한국처럼 체면을 중시하는 곳에서는 더욱 이런 신호가 크게 느껴진다. 눈으로 보여지는 것으로 사람을 판단하는 대한민국은 하이엔드 신호에 민감하게 반응할 수밖에 없는 곳이다. 물론 대한민국 모든 곳에서 이렇지 않다. 어느 정도 소비력을 갖춘 사람들이 사는 동네의 백화점이 유독 심할 뿐이다. 이런 모습을 보고 있으면 모두가 외로워하는 듯해 보인다. 명품으로 치장을 해서라도 눈에 보이지 않는 추상적인 신호를 백화점 내의 다른 사람들에게 보냄으로써 그들과 같은 무리임을 증명하려고 애쓰는 것 같다. 사람들은 자기만족이라고 하겠지만 사실 어떤 추상적 명품 무리에 속하기 위함임을 스스로도 알고 있을 것이다. 나는 뒤쳐지지 않았다는 것을 신호로 내뿜고 싶을 것이다. 못 사는 동네의 백화점은 어떨까. 혹은 잘 사는 동네의 백화점이 아닌 종합쇼핑몰 같은 곳은 어떨까. 그곳도 명품으로 치장한 사람들이 많을까? . 2021-09-13 . 두 가지의 삶 . 첫 번째 삶은 행복하게 이 순간을 즐기는 삶 두 번재 삶은 하나의 목표만을 향해 달려가는 몰입감 높은 삶 . 2021-09-14 . 매슬로의 동기이론 . 1 단계 . 생리적 욕구로 의식주 생활에 관한 욕구, 즉 본능적인 욕구를 의미 . 2 단계 . 안전의 욕구로 사람들이 신체적 및 정서적으로 안전을 추구하는 욕구를 의미 . 3 단계 . 소속감과 애정의 욕구로 어떤 단체에 소속되어 소속감을 느끼고 주위사람들에게 사랑받고 있음 느끼고자 하는 욕구 . 4 단계 . 존경의 욕구로 타인에게 인정받고자 하는 욕구 . 5 단계 . 자아실현의 욕구로 가장 높은 단계의 욕구로서 자기만족을 느끼는 단계 . 2021-09-21 . 동기부여의 종류 . 첫 번째 동기부여는 외부에서 오는 동기부여 대표적으로 체면지키기 부모님에게 자랑스러운 아들되기, 남 부끄럽지 않은 직업 갖기, 친구들에게 꿀리지 않기 등 다양한 동기부여의 원천이 존재한다. 매슬로의 동기이론에서 4단계 욕구에 해당. 즉 타인에게 인정받고자 하는 욕구. 두 번째 동기부여는 내부에서 오는 동기부여 자신이 진짜 하고 싶은 일이 무엇인지 아는 사람들이 하는 것 남들의 시선에서 비교적 자유롭다. 그리고 큰 위험 또는 시련에 흔들리지 않고 버틸 수 있다. 매슬로의 동기이론에서 5단계 욕구에 해당. 즉 자기만족을 위한 욕구. 동기이론에 의하면 고차원의 욕구와 저차원의 욕구로 나뉘어 있어 자칫하면 우열로 보일 수 있으나 모든 욕구는 동일하게 가치가 있음. 고로 아직 자기가 높은 차원의 동기부여가 아니더라도 방황하지 않고 자신의 본심을 인정하고 앞으로 해야 할 일에 집중하면 될 뿐임. . 2021-09-23 . 사무실로 짐 옮기기 . 큰 책장 3개 | 작은 책장 2개 | 도서 약 700여 권 | 사무용 의자 1개 | 프린터 1개 | 공기청정기 1개 | 아령 24kg 2개 | 커피포트 | . 2021-09-30 . 직렬과 병렬 . 우리의 에너지는 직렬로 작용한다. 반면에 인생은 병렬적이다. 다면적이다. 입체적이다. 이 둘 사이에는 항상 간극이 존재하고 이 때문에 우리는 괴로워한다. 그래도 어느 정도 괴로움을 줄일 수 있는 방법이 있다. 인생의 여러 측면 중 일부를 습관으로 커버하는 것이다. 가령 건강이라는 인생의 정말 중요한 이슈를 생각해보자. 건강한 삶을 위해선 여러 가지가 필요하다. 대표적으로 식습관과 운동이 있다. 여기에 정신 건강은 예외로 두자. 식습관은 좋은 음식을 적절한 양으로 꾸준히 먹는 것을 의미한다. 하지만 좋은 음식을 만드는 것은 귀찮고 어려운 일이다. 운동도 마찬가지로 좋은 운동을 적절하게 꾸준히 해야 한다. 하지만 좋은 운동을 꾸준히 하는 것도 귀찮고 어렵다. 만약에 식습관과 운동 모두 신경쓰기 시작한다면 분명히 우리가 매일 사용할 수 있는 에너지의 많은 부분이 이 둘에게 할당될 것이다. 그러던 와중에 만약 다른 큰 문제가 발생하면? 인생은 예상치 못한 문제를 꾸준히 던져주기 때문에 항상 이를 대비하기 위해 여분의 에너지를 남겨둘 수 밖에 없다. 그러다보니 운동과 식습관, 문제 해결 등 다양한 일을 효과적으로 처리하지 못하고 허둥지둥 되는 상황도 종종 발생한다. 내가 그러한 삶을 살아왔기 때문에 더욱 나에게 와닿는 깨달음이었다. 고로 식습관과 운동을 습관화한다면 이는 어느 정도 커버할 수 있겠다는 생각이 들었다. 습관을 잘 들이기 위해선 어떻게 해야할지는 논외로 하자. 하지만 이제 내가 몰입을 해야 하는 일을 해야 하는 시점이기에 식습관과 운동을 반드시 습관화해야겠다. 나도 놀고 싶다. 하지만 지금은 놀 때가 아니다. .",
            "url": "https://sangwon-woo.github.io/dailyblog/markdown/plan/roadmap/2021/08/14/post001.html",
            "relUrl": "/markdown/plan/roadmap/2021/08/14/post001.html",
            "date": " • Aug 14, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hi! My name is Sangwon Woo. . I’m a software developer and system trader. . Currently, I’m working with my friend. .",
          "url": "https://sangwon-woo.github.io/dailyblog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page12": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://sangwon-woo.github.io/dailyblog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}